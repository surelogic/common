#  XXXXX                          XXXXX                      
# X     X                           X
# X                                 X
# X       XX  XX  XXX XX   XXXXX    X      XXXXX   XXXXXX  XXX     XXXXX
#  XXXXX   X   X    XX  X X     X   X     X     X X    X     X    X     X
#       X  X   X    X     XXXXXXX   X     X     X X    X     X    X
#       X  X   X    X     X         X     X     X X    X     X    X
# X     X  X  XX    X     X     X   X   X X     X  XXXXX     X    X     X
#  XXXXX    XX XX XXXXX    XXXXX  XXXXXXX  XXXXX       X   XXXXX   XXXXX
#                                                      X
#                                                  XXXX
#
# Default query bank file.

#------------------------------------------------------------------------
# Numbered Queries
#
# Please keep in numerical order
#------------------------------------------------------------------------
query.00001=SELECT \
   LS.PROJECT, \
   LS.TIME, \
   OS.TIME, \
   FILTER_INFO.EXTERNAL_FILTER \
FROM \
   LATEST_SCANS LS INNER JOIN \
   SCAN FILTER_INFO ON FILTER_INFO.ID = LS.SCAN_ID LEFT OUTER JOIN \
   OLDEST_SCANS OS ON OS.PROJECT = LS.PROJECT 
query.00002=select T.NAME, T.SHORT_MESSAGE, T.UUID from FINDING_TYPE T order by 1,2
query.00003=select distinct T.NAME, A.MNEMONIC, A.LINK, A.CATEGORY from FINDING_TYPE F, ARTIFACT_TYPE A, TOOL T where T.ID=A.TOOL_ID and F.ID=A.FINDING_TYPE_ID and F.UUID='%s'
query.00004=select INFO from FINDING_TYPE where UUID='%s'
query.00007=create table VERSION (N INT NOT NULL)
query.00008=drop table VERSION
query.00009=select N from VERSION
query.00010=insert into VERSION values (0)
query.00011=update VERSION set N=%d
query.00012=select S.SCHEMANAME "SCHEMA", T.TABLENAME "TABLE NAME" from SYS.SYSTABLES T, SYS.SYSSCHEMAS S where T.SCHEMAID = S.SCHEMAID order by 1,2
query.00013=select C.COLUMNNAME "COLUMN NAME", C.COLUMNDATATYPE "TYPE NAME" from SYS.SYSCOLUMNS C, SYS.SYSTABLES T, SYS.SYSSCHEMAS S where C.REERENCEID=T.TABLEID and T.SCHEMAID=S.SCHEMAID and T.TABLENAME='%s' and S.SCHEMANAME='%s' order by C.COLUMNNUMBER
query.00014=select T.NAME, A.MESSAGE, CU.PACKAGE_NAME, SL.CLASS_NAME, SL.LINE_OF_CODE, SL.END_LINE_OF_CODE, SL.LOCATION_TYPE, SL.IDENTIFIER from ARTIFACT A, ARTIFACT_TYPE ART, TOOL T, SOURCE_LOCATION SL, COMPILATION_UNIT CU where A.ID=%d and ART.ID=A.ARTIFACT_TYPE_ID and T.ID=ART.TOOL_ID and SL.ID=A.PRIMARY_SOURCE_LOCATION_ID and CU.ID=SL.COMPILATION_UNIT_ID
query.00015=select CU.PACKAGE_NAME, SL.CLASS_NAME, SL.LINE_OF_CODE, SL.END_LINE_OF_CODE, SL.LOCATION_TYPE, SL.IDENTIFIER from ARTIFACT_SOURCE_LOCATION_RELTN ASLR, SOURCE_LOCATION SL, COMPILATION_UNIT CU where ASLR.ARTIFACT_ID=%d and SL.ID=ASLR.SOURCE_LOCATION_ID and CU.ID=SL.COMPILATION_UNIT_ID
query.00016=select A.FINDING_ID, SU.USER_NAME, A.EVENT, A.VALUE, A.DATE_TIME from SIERRA_AUDIT A left outer join SIERRA_USER SU on SU.ID = A.USER_ID where FINDING_ID=%d order by A.DATE_TIME
query.00017=select P.NAME, S.DATE_TIME, S.COMMIT_COUNT, S.UPDATE_COUNT from SYNCH S, PROJECT P where P.ID = S.PROJECT_ID order by 2 desc, 1
query.00018=delete from FIELD where RUN = ? and ID in (select ID from FIELD where RUN = ? except select FIELD from ACCESS where RUN = ?)
query.00019=delete from OBJECT where RUN=? and ID=?
query.00020=insert into RUN (Name, RawDataVersion, UserName, JavaVersion, JavaVendor, OsName, OsArch, OsVersion, MaxMemoryMB, Processors, Started) values (?,?,?,?,?,?,?,?,?,?,?)
query.00021=select * from RUN where Name=? and Started=?
query.00022=select * from RUN where Run=?
query.00023=select * from RUN
query.00024=delete from %s where Run=%d
query.00025=insert into RWLOCK (Id,ReadLock,WriteLock) values (?, ?, ?)

#------------------------------------------------------------------------
# Schema update queries
#------------------------------------------------------------------------
SchemaUtil.checkFindingTypeCategories=SELECT UUID FROM FINDING_TYPE WHERE \
	ID IN ((SELECT ID FROM FINDING_TYPE) \
		    EXCEPT \
		   (SELECT DISTINCT FINDING_TYPE_ID FROM FILTER_ENTRY WHERE FILTERED = 'N')) 
SchemaUtil.categoriesFromArtifactTypes=SELECT DISTINCT T.NAME,ART.CATEGORY,FT.UUID \
	FROM ARTIFACT_TYPE ART, TOOL T, FINDING_TYPE FT \
	WHERE T.ID = ART.TOOL_ID AND \
	FT.ID = ART.FINDING_TYPE_ID \
	ORDER BY 1,2,3
SchemaUtil.findExtensionPathConstraint=SELECT C.CONSTRAINTNAME, CO.DESCRIPTOR \
FROM \
   SYS.SYSKEYS K, \
   SYS.SYSCONGLOMERATES CO, \
   SYS.SYSCONSTRAINTS C, \
   SYS.SYSTABLES T \
WHERE \
   C.CONSTRAINTID = K.CONSTRAINTID AND \
   CO.CONGLOMERATEID = K.CONGLOMERATEID AND \
   T.TABLEID = C.TABLEID AND \
   T.TABLENAME = 'EXTENSION' AND \
   C.TYPE = 'U' 
#------------------------------------------------------------------------
# Finder queries
#------------------------------------------------------------------------

FindingsSelectionView.show=select FO.SUMMARY, FO.IMPORTANCE, FO.FINDING_ID, FO.PROJECT, FO.PACKAGE, FO.CLASS, FO.LINE_OF_CODE, FO.FINDING_TYPE, FO.FINDING_TYPE_NAME, FO.TOOL from FINDINGS_OVERVIEW FO %s order by case when FO.IMPORTANCE='Irrelevant' then 5 when FO.IMPORTANCE='Low' then 4 when FO.IMPORTANCE='Medium' then 3 when FO.IMPORTANCE='High' then 2 when FO.IMPORTANCE='Critical' then 1 end, 4,5,6,7,FO.SUMMARY
FindingsSelectionView.count=select %s, count(*) from FINDINGS_OVERVIEW FO %s group by %s

FindingsSelectionView.showJoin=select FJ.SUMMARY, FJ.IMPORTANCE, FJ.FINDING_ID, FJ.PROJECT, FJ.PACKAGE, FJ.CLASS, FJ.LINE_OF_CODE, FJ.FINDING_TYPE, FJ.FINDING_TYPE_NAME, FJ.TOOL from FINDINGS_OVERVIEW FO, FINDINGS_OVERVIEW FJ %s order by case when FJ.IMPORTANCE='Irrelevant' then 5 when FJ.IMPORTANCE='Low' then 4 when FJ.IMPORTANCE='Medium' then 3 when FJ.IMPORTANCE='High' then 2 when FJ.IMPORTANCE='Critical' then 1 end, 4,5,6,7,FJ.SUMMARY
FindingsSelectionView.countJoin=select %s, count(*) from FINDINGS_OVERVIEW FO, FINDINGS_OVERVIEW FJ %s group by %s

FindingsSelectionView.countModels=select %s, count(*), max(FO.FINDING_TYPE), max(FO.SUMMARY) from FINDINGS_OVERVIEW FO, FINDINGS_OVERVIEW FJ %s group by %s


#------------------------------------------------------------------------
# Named Queries
#------------------------------------------------------------------------
portal.finding.byId=SELECT F.ID,F.IMPORTANCE,F.SUMMARY,FT.NAME,P.NAME,LM.PACKAGE_NAME,LM.CLASS_NAME FROM FINDING F, LOCATION_MATCH LM, FINDING_TYPE FT, PROJECT P WHERE F.ID = ? AND LM.FINDING_ID = F.ID AND FT.ID = LM.FINDING_TYPE_ID AND P.ID = LM.PROJECT_ID
portal.finding.byUuid=SELECT F.ID,F.IMPORTANCE,F.SUMMARY,FT.NAME,P.NAME,LM.PACKAGE_NAME,LM.CLASS_NAME FROM FINDING F, LOCATION_MATCH LM, FINDING_TYPE FT, PROJECT P WHERE F.UUID = ? AND LM.FINDING_ID = F.ID AND FT.ID = LM.FINDING_TYPE_ID AND P.ID = LM.PROJECT_ID
portal.finding.auditsById=SELECT A.EVENT, A.VALUE, A.DATE_TIME, U.USER_NAME FROM SIERRA_AUDIT A, SIERRA_USER U WHERE FINDING_ID = ? AND U.ID = A.USER_ID ORDER BY A.DATE_TIME
portal.finding.artifactsById=SELECT S.SCAN_DATE_TIME, T.NAME, ART.MNEMONIC_DISPLAY, A.MESSAGE \
	FROM ARTIFACT_FINDING_RELTN AFR, ARTIFACT A, ARTIFACT_TYPE ART, TOOL T, SCAN S \
	WHERE AFR.FINDING_ID = ? AND A.ID = AFR.ARTIFACT_ID AND ART.ID = A.ARTIFACT_TYPE_ID AND T.ID = ART.TOOL_ID AND S.ID = A.SCAN_ID \
	ORDER BY S.SCAN_DATE_TIME DESC
#------------------------------------------------------------------------
# Revision
#------------------------------------------------------------------------
Revision.maxRevision=SELECT MAX(REVISION) FROM REVISION

#------------------------------------------------------------------------
# Finding Relations
#------------------------------------------------------------------------
FindingRelationOverview.listForParent=SELECT PARENT_FINDING_ID,CHILD_FINDING_ID,PROJECT_ID,RELATION_TYPE,STATUS from FINDING_RELATION_OVERVIEW where PARENT_FINDING_ID = ?
FindingRelationOverview.listForChild=SELECT PARENT_FINDING_ID,CHILD_FINDING_ID,PROJECT_ID,RELATION_TYPE,STATUS from FINDING_RELATION_OVERVIEW where CHILD_FINDING_ID = ?

#------------------------------------------------------------------------
# Definitional Data
#------------------------------------------------------------------------
Definitions.insertDefinition=INSERT INTO SERVER_DEFINITION_RELTN (DEFINITION_UUID,SERVER_UUID) VALUES (?,?)
Definitions.deleteDefinition=DELETE FROM SERVER_DEFINITION_RELTN WHERE DEFINITION_UUID = ?
Definitions.getDefinitionServer=SELECT SDR.SERVER_UUID, SI.NAME \
	FROM SERVER_DEFINITION_RELTN SDR LEFT OUTER JOIN SERVER_IDENTITY SI ON SI.UUID = SDR.SERVER_UUID \
	WHERE SDR.DEFINITION_UUID = ?

#------------------------------------------------------------------------
# Report Settings
#------------------------------------------------------------------------
ReportSettings.delete=DELETE FROM REPORT_SETTINGS WHERE USER_ID = ? AND UUID = ?
ReportSettings.insert=INSERT INTO REPORT_SETTINGS (USER_ID,UUID,REPORT_UUID,TITLE,DESCRIPTION) VALUES (?,?,?,?,?)
ReportSettings.insertParam=INSERT INTO REPORT_SETTINGS_PARAM (REPORT_SETTINGS_UUID,PARAM_NAME,PARAM_VALUE,ORDINAL) VALUES (?,?,?,?)
ReportSettings.selectUserSetting=SELECT UUID,REPORT_UUID,TITLE,DESCRIPTION FROM REPORT_SETTINGS WHERE USER_ID = ? AND UUID = ?
ReportSettings.listUserSettings=SELECT UUID,REPORT_UUID,TITLE,DESCRIPTION FROM REPORT_SETTINGS WHERE USER_ID = ?
ReportSettings.listSettingParams=SELECT PARAM_NAME,PARAM_VALUE FROM REPORT_SETTINGS_PARAM WHERE REPORT_SETTINGS_UUID = ? ORDER BY PARAM_NAME,ORDINAL
#------------------------------------------------------------------------
# Finding Types
#------------------------------------------------------------------------
FindingTypes.findByUid=SELECT ID,UUID,NAME,SHORT_MESSAGE,INFO FROM FINDING_TYPE WHERE UUID = ?
FindingTypes.findById=SELECT ID,UUID,NAME,SHORT_MESSAGE,INFO FROM FINDING_TYPE WHERE ID = ?
FindingTypes.findArtifactTypeById=SELECT ART.ID,T.NAME,ART.MNEMONIC,ART.MNEMONIC_DISPLAY,T.VERSION FROM ARTIFACT_TYPE ART, TOOL T WHERE ART.FINDING_TYPE_ID = ? AND T.ID = ART.TOOL_ID
FindingTypes.artifactsByTool=SELECT ART.ID,T.NAME,ART.MNEMONIC,ART.MNEMONIC_DISPLAY,T.VERSION FROM ARTIFACT_TYPE ART, TOOL T WHERE ART.TOOL_ID = T.ID AND T.NAME = ? AND T.VERSION = ?
FindingTypes.listFindingTypes=SELECT UUID FROM FINDING_TYPE ORDER BY NAME
FindingTypes.scanFiltersIncluding=SELECT S.UUID,S.NAME FROM SETTING_FILTERS SF, SETTINGS S WHERE SF.FINDING_TYPE_ID = ? AND S.ID = SF.SETTINGS_ID AND SF.FILTERED = 'N'
FindingTypes.categoriesReferencing=SELECT FS.UUID,FS.NAME,FS.INFO,FE.FILTERED FROM FILTER_ENTRY FE, FILTER_SET FS WHERE FE.FINDING_TYPE_ID = ? AND FS.ID = FE.FILTER_SET_ID
FindingTypes.excludingCategories=SELECT * FROM SETTING_FILTERS WHERE FINDING_TYPE_ID = ? AND FILTERED = 'Y'
FindingTypes.query=SELECT UUID,NAME FROM FINDING_TYPE WHERE NAME LIKE ? ORDER BY NAME
FindingTypes.registerExtension=INSERT INTO EXTENSION (NAME,VERSION,PATH) VALUES (?,?,?)
FindingTypes.registerExtensionArtifact=INSERT INTO EXTENSION_ARTIFACT_TYPE_RELTN (EXTENSION_ID,ARTIFACT_TYPE_ID) VALUES (?,?)
FindingTypes.registerExtensionFindingType=INSERT INTO EXTENSION_FINDING_TYPE_RELTN (EXTENSION_ID,FINDING_TYPE_ID) VALUES (?,?)
FindingTypes.selectExtension=SELECT ID,NAME,VERSION,PATH FROM EXTENSION WHERE NAME = ? AND VERSION = ?
FindingTypes.selectExtensions=SELECT ID,NAME,VERSION,PATH FROM EXTENSION
FindingTypes.selectExtensionArtifactTypes=SELECT FT.UUID,ART.ID,T.NAME,ART.MNEMONIC,ART.MNEMONIC_DISPLAY,T.VERSION FROM EXTENSION_ARTIFACT_TYPE_RELTN E, ARTIFACT_TYPE ART, TOOL T, FINDING_TYPE FT WHERE E.EXTENSION_ID = ? AND ART.ID = E.ARTIFACT_TYPE_ID AND T.ID = ART.TOOL_ID AND FT.ID = ART.FINDING_TYPE_ID
FindingTypes.selectExtensionFindingTypes=SELECT FT.UUID FROM EXTENSION_FINDING_TYPE_RELTN EFTR, FINDING_TYPE FT WHERE EFTR.EXTENSION_ID = ? AND FT.ID = EFTR.FINDING_TYPE_ID
FindingTypes.insertArtifactType=INSERT INTO ARTIFACT_TYPE (TOOL_ID,MNEMONIC,MNEMONIC_DISPLAY,CATEGORY,LINK,INFO,FINDING_TYPE_ID) VALUES ((SELECT ID FROM TOOL WHERE NAME = ? AND VERSION = ?),?,?,?,?,?,(SELECT ID FROM FINDING_TYPE WHERE UUID = ?))
FindingTypes.insertFindingType=INSERT INTO FINDING_TYPE (UUID,NAME,SHORT_MESSAGE,INFO) VALUES (?,?,?,?)
FindingTypes.extensionDependency=SELECT E.NAME,E.VERSION FROM FINDING_TYPE FT, EXTENSION_FINDING_TYPE_RELTN EFTR, EXTENSION E WHERE FT.UUID = ? AND EFTR.FINDING_TYPE_ID = FT.ID AND E.ID = EFTR.EXTENSION_ID 

#------------------------------------------------------------------------
# Projects
#------------------------------------------------------------------------
Projects.query=SELECT NAME FROM PROJECT WHERE NAME LIKE ? ORDER BY NAME
Projects.listProjects=SELECT P.ID,P.NAME,S.UUID FROM PROJECT P \
   LEFT OUTER JOIN SETTINGS_PROJECT_RELTN SPR ON SPR.PROJECT_NAME = P.NAME \
   LEFT OUTER JOIN SETTINGS S ON S.ID = SPR.SETTINGS_ID 
Projects.deleteScanFilter=DELETE FROM SETTINGS_PROJECT_RELTN WHERE PROJECT_NAME = ?
Projects.insertScanFilter=INSERT INTO SETTINGS_PROJECT_RELTN (PROJECT_NAME, SETTINGS_ID) VALUES (?,(SELECT ID FROM SETTINGS WHERE UUID = ?))

#------------------------------------------------------------------------
# Scans
#------------------------------------------------------------------------
Scans.projectScans=SELECT S.UUID, SU.USER_NAME, P.NAME, S.JAVA_VERSION, S.JAVA_VENDOR, S.SCAN_DATE_TIME, S.STATUS, S.IS_PARTIAL \
     FROM  PROJECT P INNER JOIN SCAN S ON S.PROJECT_ID = P.ID LEFT OUTER JOIN SIERRA_USER SU ON SU.ID = S.USER_ID WHERE P.NAME = ? \
     ORDER BY S.SCAN_DATE_TIME DESC
Scans.latestProjectScan=SELECT S.UUID, SU.USER_NAME, LS.PROJECT, S.JAVA_VERSION, S.JAVA_VENDOR, S.SCAN_DATE_TIME, S.STATUS, S.IS_PARTIAL \
     FROM LATEST_SCANS LS INNER JOIN SCAN S ON S.ID = LS.SCAN_ID LEFT OUTER JOIN SIERRA_USER SU ON SU.ID = S.USER_ID WHERE LS.PROJECT = ?
Scans.scanCompilations=SELECT CU.PACKAGE_NAME,CU.CU FROM SCAN S, METRIC_CU M, COMPILATION_UNIT CU \
   WHERE S.UUID = ? AND \
         M.SCAN_ID = S.ID AND \
         CU.ID = M.COMPILATION_UNIT_ID
Scans.scanFindingDetails=SELECT S.SCAN_DATE_TIME,P.NAME,COUNT(DISTINCT SO.FINDING_ID) \
	FROM SCAN S, PROJECT P, SCAN_OVERVIEW SO \
	WHERE S.UUID = ? AND P.ID = S.PROJECT_ID \
		AND SO.SCAN_ID = S.ID \
	GROUP BY S.SCAN_DATE_TIME,P.NAME
Scans.scanMetricDetails=SELECT COUNT(DISTINCT CU.PACKAGE_NAME), COUNT(CU.ID), SUM(M.LINES_OF_CODE) \
	FROM SCAN S, METRIC_CU M, COMPILATION_UNIT CU \
	WHERE S.UUID = ? AND M.SCAN_ID = S.ID AND CU.ID = M.COMPILATION_UNIT_ID
Scans.scanExtensions=SELECT E.NAME,E.VERSION FROM SCAN S, SCAN_EXTENSION SE, EXTENSION E \
	WHERE S.UUID = ? AND SE.SCAN_ID = S.ID AND E.ID = SE.EXTENSION_ID 
Scans.insertSettingsEntry=INSERT INTO SCAN_SETTINGS (SCAN_ID,UUID,NAME,REVISION) \
	VALUES ((SELECT ID FROM SCAN WHERE UUID = ?),?,?,?)
Scans.insertSettingFilter=INSERT INTO SCAN_SETTING_FILTERS (SCAN_ID,FINDING_TYPE_ID,IMPORTANCE,FILTERED) \
	VALUES ((SELECT ID FROM SCAN WHERE UUID = ?),(SELECT MAX(ID) FROM FINDING_TYPE WHERE UUID = ?),?,?)
Scans.selectSettingsEntry=SELECT UUID,NAME,REVISION FROM SCAN_SETTINGS WHERE SCAN_ID = (SELECT ID FROM SCAN WHERE UUID = ?)
Scans.selectSettingFilters=SELECT FT.UUID,SF.IMPORTANCE,SF.FILTERED \
	FROM SCAN_SETTING_FILTERS SF, FINDING_TYPE FT \
	WHERE FT.ID = SF.FINDING_TYPE_ID AND SF.SCAN_ID = (SELECT ID FROM SCAN WHERE UUID = ?)
Scans.unfinishedScans=SELECT UUID FROM SCAN WHERE STATUS != 'FINISHED'
Scans.insertExtension=INSERT INTO SCAN_EXTENSION (SCAN_ID, EXTENSION_ID) VALUES (?,?)
Scans.selectExtension=SELECT ID FROM EXTENSION WHERE NAME = ? AND VERSION = ?
#------------------------------------------------------------------------
# Filter Sets (Ad-Hoc Categories)
#------------------------------------------------------------------------
FilterSetRecord.generated=true
FilterSetRecord.insert=INSERT INTO FILTER_SET (UUID,REVISION,NAME,INFO) VALUES (?,?,?,?)
FilterSetRecord.select=SELECT ID,REVISION,NAME,INFO FROM FILTER_SET WHERE UUID = ?
FilterSetRecord.delete=DELETE FROM FILTER_SET WHERE ID = ?
FilterSetRecord.update=UPDATE FILTER_SET SET REVISION = ?, NAME = ?, INFO = ? WHERE ID = ?

FilterSets.latestServerRevisions=SELECT SDR.SERVER_UUID,MAX(FS.REVISION) \
   FROM FILTER_SET FS, SERVER_DEFINITION_RELTN SDR WHERE FS.UUID = SDR.DEFINITION_UUID GROUP BY SDR.SERVER_UUID
FilterSets.listServerDeletions=SELECT DEFINITION_UUID FROM DELETED_DEFINITIONS WHERE SERVER_UUID = ? AND REVISION > ? AND DEFINITION_TYPE = 'CATEGORY'
FilterSets.insertDeletedFilterSet=INSERT INTO DELETED_DEFINITIONS (DEFINITION_UUID,SERVER_UUID,REVISION,DEFINITION_TYPE) VALUES (?,?,?,'CATEGORY')
FilterSets.listServerFilterSets=SELECT FS.UUID FROM FILTER_SET FS, SERVER_DEFINITION_RELTN SDR WHERE SDR.SERVER_UUID = ? AND FS.UUID = SDR.DEFINITION_UUID
FilterSets.listFilterSets=SELECT UUID FROM FILTER_SET
FilterSets.listFilterSetFilters=SELECT FT.UUID,FE.FILTERED FROM FILTER_ENTRY FE, FINDING_TYPE FT WHERE FE.FILTER_SET_ID = ? AND FT.ID = FE.FINDING_TYPE_ID
FilterSets.listFilterSetParents=SELECT FS.UUID FROM FILTER_SET_RELTN FSR, FILTER_SET FS WHERE FSR.CHILD_ID = ? AND FS.ID = FSR.PARENT_ID
FilterSets.listFilterSetChildren=SELECT FS.UUID FROM FILTER_SET_RELTN FSR, FILTER_SET FS WHERE FSR.PARENT_ID = ? AND FS.ID = FSR.CHILD_ID
FilterSets.deleteFilterSetParents=DELETE FROM FILTER_SET_RELTN WHERE CHILD_ID = ?
FilterSets.insertFilterSetParent=INSERT INTO FILTER_SET_RELTN (CHILD_ID, PARENT_ID) VALUES (?,?)
FilterSets.findParents=SELECT PFS.UUID FROM FILTER_SET CFS, FILTER_SET PFS, FILTER_SET_RELTN FSR WHERE CFS.UUID = ? AND FSR.CHILD_ID = CFS.ID AND PFS.ID = FSR.PARENT_ID
FilterSets.deleteFilterSetEntries=DELETE FROM FILTER_ENTRY WHERE FILTER_SET_ID = ?
FilterSets.insertFilterSetEntry=INSERT INTO FILTER_ENTRY (FILTER_SET_ID, FINDING_TYPE_ID, FILTERED) VALUES (?,(SELECT MAX(ID) FROM FINDING_TYPE WHERE UUID = ?), ?)
FilterSets.query=SELECT UUID,NAME FROM FILTER_SET WHERE NAME LIKE ? ORDER BY NAME
FilterSets.scanFiltersUsing=SELECT S.UUID, S.NAME FROM SETTING_FILTER_SETS SF, SETTINGS S WHERE SF.FILTER_SET_ID = ? AND S.ID = SF.SETTINGS_ID
FilterSets.checkFindingType=SELECT UUID FROM FINDING_TYPE WHERE UUID = ?
FilterSets.extensionDependencies=SELECT DISTINCT E.NAME,E.VERSION FROM FILTER_SET FS, FILTER_ENTRY FE, EXTENSION_FINDING_TYPE_RELTN EFTR, EXTENSION E WHERE FS.UUID = ? AND FE.FILTER_SET_ID = FS.ID AND EFTR.FINDING_TYPE_ID = FE.FINDING_TYPE_ID AND E.ID = EFTR.EXTENSION_ID

#------------------------------------------------------------------------
# Scan Filters
#------------------------------------------------------------------------
ScanFilterRecord.generated=true
ScanFilterRecord.insert=INSERT INTO SETTINGS (UUID,NAME,REVISION) VALUES (?,?,?)
ScanFilterRecord.select=SELECT ID,NAME,REVISION FROM SETTINGS WHERE UUID = ?
ScanFilterRecord.delete=DELETE FROM SETTINGS WHERE ID = ?
ScanFilterRecord.update=UPDATE SETTINGS SET REVISION = ?, NAME = ? WHERE ID = ?

ScanFilters.latestServerRevisions=SELECT SDR.SERVER_UUID,MAX(S.REVISION) \
   FROM SETTINGS S, SERVER_DEFINITION_RELTN SDR WHERE S.UUID = SDR.DEFINITION_UUID GROUP BY SDR.SERVER_UUID
ScanFilters.listServerDeletions=SELECT DEFINITION_UUID FROM DELETED_DEFINITIONS WHERE SERVER_UUID = ? AND REVISION > ? AND DEFINITION_TYPE = 'SCANFILTER'
ScanFilters.insertDeletedScanFilter=INSERT INTO DELETED_DEFINITIONS (DEFINITION_UUID,SERVER_UUID,REVISION,DEFINITION_TYPE) VALUES (?,?,?,'SCANFILTER')
ScanFilters.deleteTypeFilters=DELETE FROM SETTING_FILTERS WHERE SETTINGS_ID = ?
ScanFilters.deleteCategoryFilters=DELETE FROM SETTING_FILTER_SETS WHERE SETTINGS_ID = ?
ScanFilters.insertTypeFilter=INSERT INTO SETTING_FILTERS (SETTINGS_ID,FINDING_TYPE_ID,IMPORTANCE,FILTERED) VALUES (?,(SELECT MAX(ID) FROM FINDING_TYPE WHERE UUID = ?),?,?)
ScanFilters.insertCategoryFilter=INSERT INTO SETTING_FILTER_SETS (SETTINGS_ID,FILTER_SET_ID,IMPORTANCE) VALUES (?,(SELECT MAX(ID) FROM FILTER_SET WHERE UUID = ?),?)
ScanFilters.listScanFilters=SELECT UUID FROM SETTINGS
ScanFilters.listServerScanFilters=SELECT S.UUID FROM SETTINGS S, SERVER_DEFINITION_RELTN SDR WHERE S.UUID = SDR.DEFINITION_UUID AND SDR.SERVER_UUID = ?
ScanFilters.listFilterSets=SELECT FS.UUID,SFS.IMPORTANCE FROM SETTINGS S, SETTING_FILTER_SETS SFS, FILTER_SET FS WHERE S.UUID = ? AND SFS.SETTINGS_ID = S.ID AND FS.ID = SFS.FILTER_SET_ID
ScanFilters.listFilters=SELECT FT.UUID, SF.IMPORTANCE, SF.FILTERED FROM SETTINGS S, SETTING_FILTERS SF, FINDING_TYPE FT WHERE S.UUID = ? AND SF.SETTINGS_ID = S.ID AND FT.ID = SF.FINDING_TYPE_ID 
ScanFilters.selectByProject=SELECT S.UUID FROM SETTINGS S, SETTINGS_PROJECT_RELTN SP WHERE SP.PROJECT_NAME = ? AND S.ID = SP.SETTINGS_ID
ScanFilters.selectDefault=SELECT UUID FROM DEFAULT_SETTINGS
ScanFilters.updateDefault=UPDATE DEFAULT_SETTINGS SET UUID = ?
### The following queries should not generally be called.  They are currently only used by SchemaUtil. ###
ScanFilters.updateUuid=UPDATE SETTINGS SET UUID = ? WHERE UUID = ?
ScanFilters.insertDefault=INSERT INTO DEFAULT_SETTINGS (UUID) VALUES (?)
ScanFilters.extensionDependencies=SELECT DISTINCT E.NAME,E.VERSION \
	FROM SETTINGS S, SETTING_FILTERS SF, EXTENSION_FINDING_TYPE_RELTN EFTR, EXTENSION E \
	WHERE S.UUID = ? AND \
	SF.SETTINGS_ID = S.ID AND \
	EFTR.FINDING_TYPE_ID = SF.FINDING_TYPE_ID AND \
	E.ID = EFTR.EXTENSION_ID
###                                                                                                    ###

#------------------------------------------------------------------------
# Server Locations
#------------------------------------------------------------------------
ServerLocations.checkLocation=SELECT UUID FROM SERVER_LOCATION WHERE UUID = ?
ServerLocations.deleteLocations=DELETE FROM SERVER_LOCATION
ServerLocations.insertLocation=INSERT INTO SERVER_LOCATION (UUID,PROTOCOL,HOST,PORT,CONTEXT_PATH,SERVER_USER,PASSWORD,AUTOSYNC,SAVEPASS,TEAMSERVER) VALUES (?,?,?,?,?,?,?,?,?,?)
ServerLocations.listLocations=SELECT L.UUID,S.NAME,L.PROTOCOL,L.HOST,L.PORT,L.CONTEXT_PATH,L.SERVER_USER,L.PASSWORD,L.AUTOSYNC,L.SAVEPASS,L.TEAMSERVER \
		FROM SERVER_LOCATION L, SERVER_IDENTITY S WHERE L.UUID = S.UUID
ServerLocations.deleteProjects=DELETE FROM SERVER_LOCATION_PROJECT
ServerLocations.insertServerProject=INSERT INTO SERVER_LOCATION_PROJECT (SERVER,PROJECT) VALUES (?,?)
ServerLocations.listServerProjects=SELECT PROJECT FROM SERVER_LOCATION_PROJECT WHERE SERVER = ?
ServerLocations.serverScanFilters=SELECT S.NAME,S.UUID,SF.UUID FROM SERVER_IDENTITY S, SERVER_DEFINITION_RELTN D, SETTINGS SF \
	WHERE D.SERVER_UUID = S.UUID AND SF.UUID = D.DEFINITION_UUID ORDER BY S.NAME,S.UUID
ServerLocations.checkIdentity=SELECT UUID FROM SERVER_IDENTITY WHERE UUID = ?
ServerLocations.insertIdentity=INSERT INTO SERVER_IDENTITY (UUID,NAME,REVISION) VALUES (?,?,?)
ServerLocations.deleteIdentity=DELETE FROM SERVER_IDENTITY WHERE UUID = ?
ServerLocations.selectIdentityRevision=SELECT REVISION FROM SERVER_IDENTITY WHERE UUID = ?
ServerLocations.listIdentities=SELECT UUID,NAME,REVISION FROM SERVER_IDENTITY
#------------------------------------------------------------------------
# Dashboard Settings
#------------------------------------------------------------------------
Dashboard.deleteUserSettings=DELETE FROM DASHBOARD_SETTINGS WHERE USER_ID = ?
Dashboard.insertReport=INSERT INTO DASHBOARD_SETTINGS (USER_ID,ROW_NUM,COL_NUM,REPORT_SETTINGS_UUID,OUTPUT_TYPE) VALUES (?,?,?,?,?)
Dashboard.selectReports=SELECT ROW_NUM,COL_NUM,REPORT_SETTINGS_UUID,OUTPUT_TYPE FROM DASHBOARD_SETTINGS WHERE USER_ID = ? ORDER BY ROW_NUM,COL_NUM
Dashboard.deleteReport=DELETE FROM DASHBOARD_SETTINGS WHERE USER_ID = ? AND ROW_NUM = ? AND COL_NUM = ?

#------------------------------------------------------------------------
# Plots
#------------------------------------------------------------------------
Plots.FindingType.count=SELECT COUNT(DISTINCT LM.FINDING_ID), LS.PROJECT \
	FROM LATEST_SCANS LS  INNER JOIN SCAN_OVERVIEW S ON S.SCAN_ID = LS.SCAN_ID \
	    INNER JOIN LOCATION_MATCH LM ON LM.FINDING_ID = S.FINDING_ID \
	    INNER JOIN FINDING_TYPE FT ON FT.ID = LM.FINDING_TYPE_ID AND FT.UUID = ? \
	WHERE LS.QUALIFIER = '__ALL_SCANS__' \
	GROUP BY LS.PROJECT \
	ORDER BY LS.PROJECT 

Plots.FindingTypes.count=SELECT COUNT(DISTINCT LM.FINDING_ID), LS.PROJECT \
	FROM LATEST_SCANS LS  INNER JOIN SCAN_OVERVIEW S ON S.SCAN_ID = LS.SCAN_ID \
	    INNER JOIN LOCATION_MATCH LM ON LM.FINDING_ID = S.FINDING_ID \
	    INNER JOIN FINDING_TYPE FT ON FT.ID = LM.FINDING_TYPE_ID AND FT.UUID IN ( %s ) \
	WHERE LS.QUALIFIER = '__ALL_SCANS__' \
	GROUP BY LS.PROJECT \
	ORDER BY LS.PROJECT 
	
Plots.Project.scanFindingsByProjectAndImportance=SELECT COUNT(*), \
 CASE WHEN F.IMPORTANCE = 0 THEN 'Irrelevant' \
      WHEN F.IMPORTANCE = 1 THEN 'Low' \
      WHEN F.IMPORTANCE = 2 THEN 'Medium' \
      WHEN F.IMPORTANCE = 3 THEN 'High' \
      ELSE 'Critical' END \
   ,LS.PROJECT \
   FROM LATEST_SCANS LS, SCAN_OVERVIEW SO, FINDING F \
   WHERE LS.PROJECT IN (%s) AND \
         SO.SCAN_ID = LS.SCAN_ID AND \
         F.ID = SO.FINDING_ID AND \
         F.IMPORTANCE IN (%s) \
   GROUP BY LS.PROJECT,F.IMPORTANCE \
   ORDER BY LS.PROJECT,F.IMPORTANCE 

Plots.Project.scanFindings=SELECT COUNT(*), \
 CASE WHEN F.IMPORTANCE = 0 THEN 'Irrelevant' \
      WHEN F.IMPORTANCE = 1 THEN 'Low' \
      WHEN F.IMPORTANCE = 2 THEN 'Medium' \
      WHEN F.IMPORTANCE = 3 THEN 'High' \
      ELSE 'Critical' END \
   ,S.SCAN_DATE_TIME \
   FROM SCAN S, PROJECT P, SCAN_OVERVIEW SO, FINDING F \
   WHERE P.NAME = ? AND \
         S.PROJECT_ID = P.ID AND \
         SO.SCAN_ID = S.ID AND \
         F.ID = SO.FINDING_ID AND \
         F.IMPORTANCE != 0 \
   GROUP BY S.SCAN_DATE_TIME,F.IMPORTANCE \
   ORDER BY S.SCAN_DATE_TIME,F.IMPORTANCE 

Plots.Project.linesOfCode=SELECT SUM(M.LINES_OF_CODE) \
	FROM LATEST_SCANS S, METRIC_CU M \
	WHERE S.PROJECT = ? AND M.SCAN_ID = S.SCAN_ID

Plots.Project.linesOfCodeByPackage=SELECT CU.PACKAGE_NAME, SUM(M.LINES_OF_CODE) \
	FROM LATEST_SCANS S, METRIC_CU M, COMPILATION_UNIT CU \
	WHERE S.PROJECT = ? AND M.SCAN_ID = S.SCAN_ID AND CU.ID = M.COMPILATION_UNIT_ID \
	GROUP BY CU.PACKAGE_NAME ORDER BY CU.PACKAGE_NAME

Plots.Project.compilations=SELECT COUNT(*),\
 CASE WHEN F.IMPORTANCE = 0 THEN 'Irrelevant' \
      WHEN F.IMPORTANCE = 1 THEN 'Low' \
      WHEN F.IMPORTANCE = 2 THEN 'Medium' \
      WHEN F.IMPORTANCE = 3 THEN 'High' \
      ELSE 'Critical' END \
   ,LM.PACKAGE_NAME \
   FROM LATEST_SCANS LS \
        INNER JOIN SCAN_OVERVIEW SO ON SO.SCAN_ID = LS.SCAN_ID \
        INNER JOIN FINDING F ON F.ID = SO.FINDING_ID \
        INNER JOIN LOCATION_MATCH LM ON LM.FINDING_ID = F.ID \
   WHERE LS.PROJECT = ? \
   GROUP BY LM.PACKAGE_NAME,F.IMPORTANCE \
   HAVING F.IMPORTANCE != 0 \
   ORDER BY LM.PACKAGE_NAME,F.IMPORTANCE 
   
Plots.Project.scanImportances=SELECT COUNT(*), \
 CASE WHEN F.IMPORTANCE = 0 THEN 'Irrelevant' \
      WHEN F.IMPORTANCE = 1 THEN 'Low' \
      WHEN F.IMPORTANCE = 2 THEN 'Medium' \
      WHEN F.IMPORTANCE = 3 THEN 'High' \
      ELSE 'Critical' END \
   ,S.SCAN_DATE_TIME \
   FROM SCAN S, SCAN_OVERVIEW SO, FINDING F \
   WHERE S.UUID IN (%s) AND \
         SO.SCAN_ID = S.ID AND \
         F.ID = SO.FINDING_ID AND \
         F.IMPORTANCE IN (%s) \
   GROUP BY S.SCAN_DATE_TIME,F.IMPORTANCE \
   ORDER BY S.SCAN_DATE_TIME,F.IMPORTANCE 

#Provide information on the findings that are different between two scans.  The query takes three scan UUIDs as arguments.
#It shows all findings in the first scan except for those in the second.  It looks up compilation information based on the 
#third scan argument
Plots.project.scanFindingsDiff=SELECT F.ID, \
        LM.PACKAGE_NAME, \
        SO.CU, \
        SO.LINE_OF_CODE, \
        FT.NAME, \
        SO.TOOL, \
        CASE WHEN F.IS_READ = 'Y' THEN 'Yes' ELSE 'No' END, \
        F.LAST_CHANGED, \
        CASE \
             WHEN F.IMPORTANCE=0 THEN 'Irrelevant' \
 	         WHEN F.IMPORTANCE=1 THEN 'Low' \
             WHEN F.IMPORTANCE=2 THEN 'Medium' \
             WHEN F.IMPORTANCE=3 THEN 'High' \
             WHEN F.IMPORTANCE=4 THEN 'Critical' \
        END, \
        SO.ARTIFACT_COUNT, \
        CASE WHEN COUNT.COUNT IS NULL THEN 0 ELSE COUNT.COUNT END, \
        F.SUMMARY, \
        LM.CLASS_NAME \
 FROM \
 	(SELECT FINDING_ID FROM SCAN_OVERVIEW WHERE SCAN_ID = (SELECT ID FROM SCAN WHERE UUID = ?) \
	EXCEPT \
	SELECT FINDING_ID FROM SCAN_OVERVIEW WHERE SCAN_ID = (SELECT ID FROM SCAN WHERE UUID = ?)) AS FINDINGS \
    INNER JOIN SCAN_OVERVIEW SO ON SO.FINDING_ID = FINDINGS.FINDING_ID \
    INNER JOIN FINDING F ON F.ID = SO.FINDING_ID \
    LEFT OUTER JOIN ( \
       SELECT \
          A.FINDING_ID "ID", COUNT(*) "COUNT" \
       FROM SIERRA_AUDIT A \
       GROUP BY A.FINDING_ID) AS COUNT ON COUNT.ID = F.ID \
    INNER JOIN LOCATION_MATCH LM ON LM.FINDING_ID = F.ID \
    INNER JOIN FINDING_TYPE FT ON FT.ID = LM.FINDING_TYPE_ID \
  WHERE SO.SCAN_ID = (SELECT ID FROM SCAN WHERE UUID = ?) \
 ORDER BY LM.PACKAGE_NAME, SO.CU, SO.LINE_OF_CODE

Plots.Project.compareScans=SELECT F.ID, \
        LM.PACKAGE_NAME, \
        SO.CU, \
        SO.LINE_OF_CODE, \
        FT.NAME, \
        SO.TOOL, \
        CASE WHEN F.IS_READ = 'Y' THEN 'Yes' ELSE 'No' END, \
        F.LAST_CHANGED, \
        CASE \
             WHEN F.IMPORTANCE=0 THEN 'Irrelevant' \
 	         WHEN F.IMPORTANCE=1 THEN 'Low' \
             WHEN F.IMPORTANCE=2 THEN 'Medium' \
             WHEN F.IMPORTANCE=3 THEN 'High' \
             WHEN F.IMPORTANCE=4 THEN 'Critical' \
        END, \
        CASE \
	            WHEN EARLIER.FINDING_ID IS NOT NULL THEN 'Unchanged' \
	            ELSE 'New' \
        END, \
        SO.ARTIFACT_COUNT, \
        CASE WHEN COUNT.COUNT IS NULL THEN 0 ELSE COUNT.COUNT END, \
        F.SUMMARY, \
        LM.CLASS_NAME \
 FROM \
    SCAN S \
    INNER JOIN SCAN_OVERVIEW SO ON SO.SCAN_ID = S.ID \
    INNER JOIN FINDING F ON F.ID = SO.FINDING_ID \
    LEFT OUTER JOIN SCAN_OVERVIEW EARLIER ON EARLIER.FINDING_ID = F.ID \
    LEFT OUTER JOIN ( \
       SELECT \
          A.FINDING_ID \"ID\", COUNT(*) \"COUNT\" \
       FROM SIERRA_AUDIT A \
       GROUP BY A.FINDING_ID) AS COUNT ON COUNT.ID = F.ID \
    INNER JOIN LOCATION_MATCH LM ON LM.FINDING_ID = F.ID \
    INNER JOIN FINDING_TYPE FT ON FT.ID = LM.FINDING_TYPE_ID \
 WHERE EARLIER.SCAN_ID = (SELECT ID FROM SCAN WHERE UUID = ?) AND S.UUID = ? \
 ORDER BY LM.PACKAGE_NAME, SO.CU, SO.LINE_OF_CODE

Plots.Scan.packageImportances=SELECT COUNT(*), \
 CASE WHEN F.IMPORTANCE = 0 THEN 'Irrelevant' \
      WHEN F.IMPORTANCE = 1 THEN 'Low' \
      WHEN F.IMPORTANCE = 2 THEN 'Medium' \
      WHEN F.IMPORTANCE = 3 THEN 'High' \
      ELSE 'Critical' END \
   ,LM.PACKAGE_NAME \
   FROM SCAN S, SCAN_OVERVIEW SO, LOCATION_MATCH LM, FINDING F \
   WHERE S.UUID = '%s' AND \
         SO.SCAN_ID = S.ID AND \
         LM.FINDING_ID = SO.FINDING_ID AND \
         LM.PACKAGE_NAME IN (%s) AND \
         F.ID = LM.FINDING_ID AND \
         F.IMPORTANCE IN (%s) \
   GROUP BY LM.PACKAGE_NAME,F.IMPORTANCE \
   ORDER BY LM.PACKAGE_NAME,F.IMPORTANCE
   
Plots.Scan.packageImportancesByCategory=SELECT COUNT(*), \
 CASE WHEN F.IMPORTANCE = 0 THEN 'Irrelevant' \
      WHEN F.IMPORTANCE = 1 THEN 'Low' \
      WHEN F.IMPORTANCE = 2 THEN 'Medium' \
      WHEN F.IMPORTANCE = 3 THEN 'High' \
      ELSE 'Critical' END \
   ,LM.PACKAGE_NAME \
   FROM SCAN S, SCAN_OVERVIEW SO, LOCATION_MATCH LM, FINDING F, FINDING_TYPE FT \
   WHERE S.UUID = '%s' AND \
         SO.SCAN_ID = S.ID AND \
         LM.FINDING_ID = SO.FINDING_ID AND \
         LM.PACKAGE_NAME IN (%s) AND \
		 FT.ID = LM.FINDING_TYPE_ID AND \
		 FT.UUID IN (%s) AND \
         F.ID = LM.FINDING_ID AND \
         F.IMPORTANCE IN (%s) \
   GROUP BY LM.PACKAGE_NAME,F.IMPORTANCE \
   ORDER BY LM.PACKAGE_NAME,F.IMPORTANCE
   
Plots.Scan.scanFindings=SELECT F.ID, \
        LM.PACKAGE_NAME, \
        SO.CU, \
        SO.LINE_OF_CODE, \
        CASE \
             WHEN F.IMPORTANCE=0 THEN 'Irrelevant' \
 	         WHEN F.IMPORTANCE=1 THEN 'Low' \
             WHEN F.IMPORTANCE=2 THEN 'Medium' \
             WHEN F.IMPORTANCE=3 THEN 'High' \
             WHEN F.IMPORTANCE=4 THEN 'Critical' \
        END, \
        F.SUMMARY \
 FROM \
    SCAN S \
    INNER JOIN SCAN_OVERVIEW SO ON SO.SCAN_ID = S.ID \
    INNER JOIN FINDING F ON F.ID = SO.FINDING_ID \
    INNER JOIN LOCATION_MATCH LM ON LM.FINDING_ID = F.ID \
 WHERE S.UUID = '%s' AND LM.PACKAGE_NAME IN (%s) AND F.IMPORTANCE IN (%s) \
 ORDER BY LM.PACKAGE_NAME, SO.CU, SO.LINE_OF_CODE
 
 Plots.Scan.scanFindingsByCategory=SELECT F.ID, \
        LM.PACKAGE_NAME, \
        SO.CU, \
        SO.LINE_OF_CODE, \
        CASE \
             WHEN F.IMPORTANCE=0 THEN 'Irrelevant' \
 	         WHEN F.IMPORTANCE=1 THEN 'Low' \
             WHEN F.IMPORTANCE=2 THEN 'Medium' \
             WHEN F.IMPORTANCE=3 THEN 'High' \
             WHEN F.IMPORTANCE=4 THEN 'Critical' \
        END, \
        F.SUMMARY \
 FROM \
    SCAN S \
    INNER JOIN SCAN_OVERVIEW SO ON SO.SCAN_ID = S.ID \
    INNER JOIN FINDING F ON F.ID = SO.FINDING_ID \
    INNER JOIN LOCATION_MATCH LM ON LM.FINDING_ID = F.ID \
    INNER JOIN FINDING_TYPE FT ON FT.ID = LM.FINDING_TYPE_ID \
 WHERE S.UUID = '%s' AND LM.PACKAGE_NAME IN (%s) AND FT.UUID IN (%s) AND F.IMPORTANCE IN (%s) \
 ORDER BY LM.PACKAGE_NAME, SO.CU, SO.LINE_OF_CODE

# Source View
ViewSource.findIdentifiers=SELECT DISTINCT S.IDENTIFIER,S.LOCATION_TYPE \
FROM \
	ARTIFACT_FINDING_RELTN AFR, \
	ARTIFACT A, \
	SOURCE_LOCATION S \
WHERE AFR.FINDING_ID = ? AND A.ID = AFR.ARTIFACT_ID AND S.ID = A.PRIMARY_SOURCE_LOCATION_ID 
ViewSource.findIdentifiersBySecondarySources=SELECT DISTINCT S.IDENTIFIER,S.LOCATION_TYPE \
FROM \
	ARTIFACT_FINDING_RELTN AFR, \
	ARTIFACT_SOURCE_LOCATION_RELTN A, \
	SOURCE_LOCATION S \
WHERE AFR.FINDING_ID = ? AND A.ARTIFACT_ID = AFR.ARTIFACT_ID AND S.ID = A.SOURCE_LOCATION_ID

#------------------------------------------------------------------------
#                    FLASHLIGHT
#------------------------------------------------------------------------
#Run DAO
RunDAO.insert=insert into RUN (Name, RawDataVersion, Hostname, UserName, JavaVersion, JavaVendor, OsName, OsArch, OsVersion, MaxMemoryMB, Processors, Started, Duration) values (?,?,?,?,?,?,?,?,?,?,?,?,?)
RunDAO.select=select Name, RawDataVersion, UserName, JavaVersion, JavaVendor, OsName, OsArch, OsVersion, MaxMemoryMB, Processors, Started, Duration from RUN


#Support for lock trace funciton
LockTrace.selectById=SELECT \
   LT.ID, \
   LT.PARENT, \
   LT.LOCK, \
   LT.TRACE, \
   LT.TYPE, \
   O.PACKAGENAME, \
   O.CLASSNAME, \
   O.CLASSCODE, \
   S.LOCATION, \
   S.LOCATIONCODE, \
   S.ATLINE \
FROM \
   LOCKTRACE LT, \
   TRACE T, \
   SITE S, \
   OBJECT O \
WHERE  \
   LT.ID = ? AND  \
   T.ID = LT.TRACE AND \
   S.ID = T.SITE AND \
   O.ID = S.INCLASS
#Support for trace function
Trace.selectById=SELECT T.ID,T.PARENT,O.CLASSNAME,O.CLASSCODE,O.PACKAGENAME,S.INFILE,S.LOCATION,S.LOCATIONCODE,S.ATLINE,S.METHODCLASS,S.METHODCALL,S.METHODCODE \
 FROM TRACE T, SITE S, OBJECT O \
 WHERE T.ID = ? AND S.ID = T.SITE AND O.ID = S.INCLASS
#Support for viewing all field accesses
Accesses.selectByField=SELECT A.INTHREAD, THO.THREADNAME , A.TS, A.RW \
 FROM ACCESS A, OBJECT THO \
WHERE  \
   THO.Id = A.InThread AND \
   A.FIELD = ? AND  \
   A.RECEIVER IS NULL \
ORDER BY A.TS ASC 
Accesses.selectByFieldAndReceiver=SELECT A.INTHREAD, THO.THREADNAME, A.TS, A.RW, A.UNDERCONSTRUCTION \
 FROM ACCESS A, OBJECT THO \
WHERE  \
   THO.Id = A.InThread AND \
   A.FIELD = ? AND  \
   A.RECEIVER = ? \
ORDER BY A.TS ASC
Accesses.selectByObject=SELECT A.INTHREAD, THO.THREADNAME , A.TS \
 FROM INDIRECTACCESS A, OBJECT THO \
WHERE  \
   THO.Id = A.InThread AND \
   A.RECEIVER = ? \
ORDER BY A.TS ASC 

Accesses.prep.updateLockInfoMaxTypes=UPDATE LOCKINFO SET MAXTYPES = ? WHERE LOCK = ? AND TYPE = ? AND INTHREAD = ?
Accesses.prep.selectLockInfoMaxTypes=SELECT \
    MAX(AGG.TYPES) "MAXTYPES", \
    L.LOCK, \
    L.TYPE, \
    L.INTHREAD \
FROM ( \
   SELECT  \
      E.EVENT, \
      COUNT(DISTINCT S.INCLASS) "TYPES" \
   FROM ( \
      SELECT \
         ALH.LASTACQUISITION "EVENT", \
         A.TRACE \
      FROM \
         ACCESSLOCKSHELD ALH, \
         ACCESS A \
      WHERE \
         A.ID = ALH.ACCESS  \
      UNION ALL \
      SELECT \
         LH.LOCKHELDEVENT "EVENT", \
         A.TRACE \
      FROM \
         ACCESSLOCKSHELD ALH, \
         LOCKSHELD LH, \
         ACCESS A \
      WHERE \
         A.ID = ALH.ACCESS AND \
         LH.LOCKEVENT=ALH.LASTACQUISITION \
      ) E,  \
        TRACE T, \
        SITE S \
   WHERE  \
      T.ID = E.TRACE AND \
      S.ID = T.SITE \
   GROUP BY E.EVENT \
   ) AGG, \
   LOCK L \
WHERE L.ID = AGG.EVENT \
GROUP BY L.LOCK,L.TYPE,L.INTHREAD
Accesses.prep.updateLockInfoMaxPackages=UPDATE LOCKINFO SET MAXPACKAGES = ? WHERE LOCK = ? AND TYPE = ? AND INTHREAD = ?
Accesses.prep.selectLockInfoMaxPackages=SELECT \
    MAX(AGG.PACKAGES) "MAXPACKAGES", \
    L.LOCK, \
    L.TYPE, \
    L.INTHREAD \
FROM ( \
   SELECT  \
      E.EVENT, \
      COUNT(DISTINCT CO.PACKAGENAME) "PACKAGES" \
   FROM ( \
      SELECT \
         ALH.LASTACQUISITION "EVENT", \
         A.TRACE \
      FROM \
         ACCESSLOCKSHELD ALH, \
         ACCESS A \
      WHERE \
         A.ID = ALH.ACCESS  \
      UNION ALL \
      SELECT \
         LH.LOCKHELDEVENT "EVENT", \
         A.TRACE \
      FROM \
         ACCESSLOCKSHELD ALH, \
         LOCKSHELD LH, \
         ACCESS A \
      WHERE \
         A.ID = ALH.ACCESS AND \
         LH.LOCKEVENT=ALH.LASTACQUISITION \
      ) E,  \
        TRACE T, \
        SITE S, \
        OBJECT CO \
   WHERE  \
      T.ID = E.TRACE AND \
      S.ID = T.SITE AND \
      CO.ID = S.INCLASS \
   GROUP BY E.EVENT \
   ) AGG, \
   LOCK L \
WHERE L.ID = AGG.EVENT \
GROUP BY L.LOCK,L.TYPE,L.INTHREAD

Accesses.prep.lockThreadInfo.insert=INSERT INTO LOCKINFO (LOCK,TYPE,INTHREAD,DURATION,AVERAGE,INTRINSIC,JUC) VALUES (?,?,?,?,?,' ',' ')
Accesses.prep.lockThreadInfo.updateJUC=UPDATE LOCKINFO SET JUC = 'Y' WHERE LOCK = ? AND TYPE = ? AND INTHREAD = ?
Accesses.prep.lockThreadInfo.updateIntrinsic=UPDATE LOCKINFO SET INTRINSIC = 'Y' WHERE LOCK = ? AND TYPE = ? AND INTHREAD = ?
Accesses.prep.lockThreadInfo.updateCount=UPDATE LOCKINFO SET COUNT = ? WHERE LOCK = ? AND TYPE = ? AND INTHREAD = ?
Accesses.prep.lockThreadInfo.selectForInsert=SELECT  \
      LD.LOCK,  \
      LD.TYPE,  \
      LD.INTHREAD,  \
      SUM(LD.DURATION) "DURATION",  \
      SUM(LD.DURATION) / COUNT(LD.LOCK) "AVERAGE"  \
FROM   \
      LOCKDURATION LD  \
WHERE LD.STATE = 'BLOCKING'  \
GROUP BY LD.LOCK,LD.TYPE,LD.INTHREAD
Accesses.prep.lockThreadInfo.selectForUpdateJUC=SELECT DISTINCT LOCK,TYPE,INTHREAD FROM LOCK WHERE TYPE = 'U'
Accesses.prep.lockThreadInfo.selectForUpdateIntrinsic=SELECT DISTINCT LOCK,TYPE,INTHREAD FROM LOCK WHERE TYPE = 'I'
Accesses.prep.lockThreadInfo.selectForUpdateCount=SELECT  \
      COUNT(LOCK) "COUNT",  \
      LOCK,  \
      TYPE,  \
      INTHREAD  \
FROM LOCK  \
WHERE STATE='AFTER ACQUISITION'  \
GROUP BY LOCK,TYPE,INTHREAD

Accesses.prep.packageAccessCounts=INSERT INTO LOCKPACKAGE \
SELECT \
   L.LOCK, \
   L.TYPE, \
   MAX(AGG.PACKAGES) \
FROM ( \
   SELECT \
      E.EVENT, \
      COUNT(DISTINCT CO.PACKAGENAME) "PACKAGES" \
   FROM ( \
      SELECT \
         ALH.LASTACQUISITION "EVENT", \
         A.TRACE \
      FROM \
         ACCESSLOCKSHELD ALH, \
         ACCESS A \
      WHERE \
         A.ID = ALH.ACCESS \
      UNION ALL \
      SELECT \
         LH.LOCKHELDEVENT "EVENT", \
         A.TRACE \
      FROM \
         ACCESSLOCKSHELD ALH, \
         LOCKSHELD LH, \
         ACCESS A \
      WHERE \
         A.ID = ALH.ACCESS AND \
         LH.LOCKEVENT=ALH.LASTACQUISITION \
      ) E, \
      TRACE T, \
      SITE S, \
      OBJECT CO \
   WHERE \
      T.ID = E.TRACE AND \
      S.ID = T.SITE AND \
      CO.ID = S.INCLASS \
   GROUP BY E.EVENT \
   HAVING COUNT(DISTINCT CO.PACKAGENAME) >= 2 \
   ) AGG, \
   LOCK L \
WHERE L.ID = AGG.EVENT \
GROUP BY L.LOCK, L.TYPE
 
Accesses.prep.selectClassAccesses=SELECT \
   A.INTHREAD, \
   A.TS, \
   A.TRACE, \
   A.UNDERCONSTRUCTION, \
   O.PACKAGENAME, \
   O.CLASSNAME \
FROM  \
   ACCESS A, \
   FIELD F, \
   OBJECT O \
WHERE  \
   A.FIELD = F.ID AND \
   F.STATIC = 'Y' AND \
   O.ID = F.DECLARINGTYPE 
Accesses.prep.insertBadHappensBefore=INSERT INTO BADHAPPENSBEFORE (FIELD, RECEIVER) VALUES (?,?)
Accesses.prep.insertClassInit=INSERT INTO CLASSINIT (OBJ, INTHREAD, TRACE, TS) VALUES (?,?,?,?)
Accesses.prep.insertClassAccess=INSERT INTO CLASSACCESS (OBJ, INTHREAD, TRACE, TS) VALUES (?,?,?,?)
Accesses.prep.selectClass=SELECT ID FROM OBJECT WHERE PACKAGENAME = ? AND CLASSNAME = ?
Accesses.prep.volatileReads=INSERT INTO HAPPENSBEFOREVOLATILEREAD SELECT F.ID, A.TS, A.INTHREAD, A.TRACE FROM ACCESS A, FIELD F WHERE A.FIELD = F.ID AND F.VOLATILE = 'Y' AND A.RW = 'R'
Accesses.prep.volatileWrites=INSERT INTO HAPPENSBEFOREVOLATILEWRITE SELECT F.ID, A.TS, A.INTHREAD, A.TRACE FROM ACCESS A, FIELD F WHERE A.FIELD = F.ID AND F.VOLATILE = 'Y' AND A.RW = 'W'
Accesses.prep.selectStaticField=SELECT INTHREAD,TS,RW FROM ACCESS WHERE FIELD = ? ORDER BY TS
Accesses.prep.selectInstanceField=SELECT INTHREAD,TS,RW FROM ACCESS WHERE FIELD = ? AND RECEIVER = ? ORDER BY TS
Accesses.prep.selectFields=SELECT I.FIELD,I.RECEIVER FROM INTERESTINGFIELD I WHERE I.RECEIVER IS NOT NULL
Accesses.prep.selectStatics=SELECT I.FIELD FROM INTERESTINGFIELD I WHERE I.RECEIVER IS NULL 
Accesses.prep.interleavingFields=SELECT FIELD,INTHREAD FROM ACCESS WHERE RECEIVER = ? AND TS >= ? AND TS <= ? ORDER BY TS
Accesses.prep.selectAccessesInBlock=SELECT A.FIELD,F.FIELDNAME,F.CODE,A.INTHREAD,THO.THREADNAME,A.TS,A.RW,A.UNDERCONSTRUCTION FROM ACCESS A, FIELD F, OBJECT THO WHERE THO.ID = A.INTHREAD AND F.ID = A.FIELD AND A.RECEIVER = ? AND A.TS >= ? AND A.TS <= ? ORDER BY A.TS
Accesses.prep.selectAccessesInBlockByFields=SELECT A.FIELD,F.FIELDNAME,F.CODE,A.INTHREAD,THO.THREADNAME,A.TS,A.RW,A.UNDERCONSTRUCTION FROM ACCESS A, FIELD F, OBJECT THO WHERE THO.ID = A.INTHREAD AND F.ID = A.FIELD AND A.RECEIVER = ? AND A.TS >= ? AND A.TS <= ? AND (A.FIELD = ? OR A.FIELD = ?) ORDER BY A.TS
Accesses.prep.isFieldLock=SELECT 'Y' FROM FIELDASSIGNMENT FA, LOCK L WHERE L.LOCK = FA.VALUE AND FA.FIELD = ? AND FA.RECEIVER = ?
Accesses.prep.insertBlockStats=INSERT INTO BLOCKSTATS (FIELD, RECEIVER, INTHREAD, START, STOP, READS, WRITES, QUOTIENT) VALUES (?,?,?,?,?,?,?,?)
Accesses.prep.insertFieldBlockStats=INSERT INTO FIELDBLOCKSTATS (FIELD, RFIELD, RECEIVER, INTHREAD, START, STOP, READS, WRITES, QUOTIENT) VALUES (?,?,?,?,?,?,?,?,?)
Accesses.happensBefore=SELECT TARGET,TS FROM HAPPENSBEFORE WHERE SOURCE = ? AND TS BETWEEN ? AND ?
Accesses.happensBeforeVolatileWrite=SELECT FIELD,TS FROM HAPPENSBEFOREVOLATILEWRITE --DERBY-PROPERTIES index=HAPPENSBEFOREVOLATILEWRITE_INDEX \n WHERE INTHREAD = ? AND TS BETWEEN ? AND ?
Accesses.happensBeforeVolatileRead=SELECT FIELD,TS FROM HAPPENSBEFOREVOLATILEREAD --DERBY-PROPERTIES index=HAPPENSBEFOREVOLATILEREAD_INDEX \n WHERE INTHREAD = ? AND TS BETWEEN ? AND ?
Accesses.happensBeforeSourceObject=SELECT OBJ,TS,ID FROM HAPPENSBEFORESOURCE --DERBY-PROPERTIES index=HAPPENSBEFORESOURCE_TS_INDEX \n WHERE INTHREAD = ? AND TS BETWEEN ? AND ?
Accesses.happensBeforeTargetObject=SELECT OBJ,TS,ID FROM HAPPENSBEFORETARGET --DERBY-PROPERTIES index=HAPPENSBEFORETARGET_TS_INDEX \n WHERE INTHREAD = ? AND TS BETWEEN ? AND ?
Accesses.happensBeforeSourceLock=SELECT LOCK,TYPE,STOP FROM LOCKDURATION --DERBY-PROPERTIES index=LOCKDURATION_STOP_INDEX \n WHERE INTHREAD = ? AND STOP BETWEEN ? AND ? AND STATE = 'HOLDING'
Accesses.happensBeforeTargetLock=SELECT LOCK,TYPE,START FROM LOCKDURATION --DERBY-PROPERTIES index=LOCKDURATION_START_INDEX \n WHERE INTHREAD = ? AND START BETWEEN ? AND ? AND STATE = 'HOLDING'
Accesses.happensBeforeSourceColl=SELECT COLL,OBJ,MIN(TS),ID FROM HAPPENSBEFORECOLLSOURCE --DERBY-PROPERTIES index=HAPPENSBEFORECOLLSOURCE_TS_INDEX \n WHERE INTHREAD = ? AND TS BETWEEN ? AND ? GROUP BY OBJ, COLL, ID ORDER BY OBJ, COLL, ID
Accesses.happensBeforeTargetColl=SELECT COLL,OBJ,MAX(TS),ID FROM HAPPENSBEFORECOLLTARGET --DERBY-PROPERTIES index=HAPPENSBEFORECOLLTARGET_TS_INDEX \n WHERE INTHREAD = ? AND TS BETWEEN ? AND ? GROUP BY OBJ, COLL, ID ORDER BY OBJ, COLL, ID
Accesses.happensBeforeClassInit=SELECT I.OBJ FROM CLASSINIT I, CLASSACCESS A WHERE I.INTHREAD = ? AND I.TS > ? AND A.INTHREAD = ? AND A.TS < ? AND A.OBJ = I.OBJ   
Accesses.trace.happensBefore=SELECT TS,TRACE,ID,TARGET FROM HAPPENSBEFORE WHERE SOURCE = ? AND TS BETWEEN ? AND ?
Accesses.trace.happensBeforeVolatileWrite=SELECT FIELD,TS,TRACE,F.FIELDNAME FROM HAPPENSBEFOREVOLATILEWRITE --DERBY-PROPERTIES index=HAPPENSBEFOREVOLATILEWRITE_INDEX \n, FIELD F WHERE INTHREAD = ? AND TS BETWEEN ? AND ? AND F.ID = HAPPENSBEFOREVOLATILEWRITE.FIELD 
Accesses.trace.happensBeforeVolatileRead=SELECT FIELD,TS,TRACE,FIELD FROM HAPPENSBEFOREVOLATILEREAD --DERBY-PROPERTIES index=HAPPENSBEFOREVOLATILEREAD_INDEX \n WHERE INTHREAD = ? AND TS BETWEEN ? AND ?
Accesses.trace.happensBeforeSourceObject=SELECT OBJ,TS,TRACE,ID FROM HAPPENSBEFORESOURCE --DERBY-PROPERTIES index=HAPPENSBEFORESOURCE_TS_INDEX \n WHERE INTHREAD = ? AND TS BETWEEN ? AND ?
Accesses.trace.happensBeforeTargetObject=SELECT OBJ,TS,TRACE,ID FROM HAPPENSBEFORETARGET --DERBY-PROPERTIES index=HAPPENSBEFORETARGET_TS_INDEX \n WHERE INTHREAD = ? AND TS BETWEEN ? AND ?
Accesses.trace.happensBeforeSourceColl=SELECT COLL,OBJ,TS,TRACE,ID FROM HAPPENSBEFORECOLLSOURCE --DERBY-PROPERTIES index=HAPPENSBEFORECOLLSOURCE_TS_INDEX \n WHERE INTHREAD = ? AND TS BETWEEN ? AND ?
Accesses.trace.happensBeforeTargetColl=SELECT COLL,OBJ,TS,TRACE,ID FROM HAPPENSBEFORECOLLTARGET --DERBY-PROPERTIES index=HAPPENSBEFORECOLLTARGET_TS_INDEX \n WHERE INTHREAD = ? AND TS BETWEEN ? AND ?
Accesses.trace.happensBeforeSourceLock=SELECT LOCK,TYPE,TS,TRACE,CASE WHEN TYPE = 'U' THEN 'java.util.concurrent' ELSE 'Intrinsic' END FROM LOCK WHERE INTHREAD = ? AND (TS BETWEEN ? AND ?) AND STATE = 'AFTER RELEASE' AND (SUCCESS = 'Y' OR SUCCESS IS NULL) 
Accesses.trace.happensBeforeTargetLock=SELECT LOCK,TYPE,TS,TRACE,CASE WHEN TYPE = 'U' THEN 'java.util.concurrent' ELSE 'Intrinsic' END FROM LOCK WHERE INTHREAD = ? AND (TS BETWEEN ? AND ?) AND STATE = 'AFTER ACQUISITION' AND (SUCCESS IS NULL OR SUCCESS = 'Y')
Accesses.trace.happensBeforeClassInit=SELECT I.TS,I.TRACE,A.TS,A.TRACE,CO.PACKAGENAME,CO.CLASSNAME FROM CLASSINIT I, CLASSACCESS A, OBJECT CO WHERE I.INTHREAD = ? AND I.TS > ? AND A.INTHREAD = ? AND A.TS < ? AND A.OBJ = I.OBJ AND CO.ID = A.OBJ
Accesses.trace.happensBeforeLookupAccess=SELECT TRACE FROM ACCESS WHERE TS = ? AND INTHREAD = ?
Accesses.trace.traceMethodCalled=SELECT S.METHODCLASS,S.METHODCALL,S.METHODSPEC FROM TRACE T, SITE S WHERE T.ID = ? AND S.ID = T.SITE
Accesses.trace.fieldName=SELECT FIELDNAME FROM FIELD WHERE ID = ?
Accesses.trace.accessCounts=SELECT OBJID(INTHREAD), RW, UNDERCONSTRUCTION, COUNT(ID) FROM ACCESS WHERE FIELD = ? AND RECEIVER = ? AND TRACE = ? GROUP BY INTHREAD,RW,UNDERCONSTRUCTION ORDER BY INTHREAD
Accesses.trace.allAccessCounts=SELECT OBJID(INTHREAD), RW, UNDERCONSTRUCTION, COUNT(ID) FROM ACCESS WHERE FIELD = ? AND TRACE = ? GROUP BY INTHREAD,RW,UNDERCONSTRUCTION ORDER BY INTHREAD
Accesses.trace.staticAccessCounts=SELECT OBJID(INTHREAD), RW, UNDERCONSTRUCTION, COUNT(ID) FROM ACCESS WHERE FIELD = ? AND TRACE = ? GROUP BY INTHREAD,RW,UNDERCONSTRUCTION ORDER BY INTHREAD
Accesses.isFieldVolatile=SELECT VOLATILE FROM FIELD WHERE ID = ?
Accesses.isFieldFinal=SELECT FINAL FROM FIELD WHERE ID = ?
Accesses.isFieldStatic=SELECT STATIC FROM FIELD WHERE ID = ?

#Support for lock trace threads function
LockTrace.threads=SELECT OBJID(INTHREAD), COUNT(*) FROM LOCK WHERE LOCKTRACE = ? AND STATE = 'AFTER ACQUISITION' GROUP BY INTHREAD ORDER BY OBJID(INTHREAD)
LockEdge.threads=SELECT OBJID(THREAD), COUNT FROM LOCKCYCLETHREAD WHERE COMPONENT = ? AND LOCKHELD = ? AND LOCKHELDTYPE = ? AND LOCKACQUIRED = ? AND LOCKACQUIREDTYPE = ?
#Support for object id function
ObjectId.selectObjectClass=SELECT O.CLASSNAME,CO.CLASSNAME FROM OBJECT O, OBJECT CO WHERE O.ID = ? AND CO.ID = O.TYPE
ObjectId.threadName=SELECT THREADNAME FROM OBJECT WHERE ID = ? AND FLAG = 'T'
#Support for finding the lock id from the lock object for read/write locks
LockId.selectRWLock=SELECT ID FROM RWLOCK WHERE ? IN (READLOCK,WRITELOCK)
# Calculate and write out the set of fields that are accessed by more than one thread during object construction.
LockSet.v2.badPublishes=SELECT A.FIELD,A.RECEIVER FROM ACCESS A \
 WHERE A.UNDERCONSTRUCTION = 'Y' AND A.RECEIVER IS NOT NULL \
 GROUP BY A.FIELD,A.RECEIVER \
 HAVING COUNT(DISTINCT A.INTHREAD) > 1
LockSet.v2.insertBadPublish=INSERT INTO BADPUBLISH (FIELD,RECEIVER) VALUES (?,?)
# The set of non-final, non-volatile fields that have writes outside of construction and are accessed by more than one thread
LockSet.v2.interestingFields=(SELECT DISTINCT A.FIELD,A.RECEIVER FROM \
       ACCESS A, FIELD F \
WHERE A.RW = 'W' AND A.UNDERCONSTRUCTION = 'N' AND F.VOLATILE = 'N' AND F.FINAL = 'N' AND F.ID = A.FIELD) INTERSECT \
(SELECT FIELD,RECEIVER FROM \
       ACCESS \
WHERE UNDERCONSTRUCTION = 'N' \
GROUP BY FIELD,RECEIVER \
HAVING COUNT(DISTINCT INTHREAD) > 1)

LockSet.v2.insertInterestingField=INSERT INTO INTERESTINGFIELD (FIELD,RECEIVER) VALUES (?,?)
# All field accesses, and the locks that are held.  If it is a RW lock, the parent lock is provided instead

LockSet.v2.sharedFields=SELECT FIELD, RECEIVER FROM \
	FIELDINSTANCETHREAD \
WHERE READCOUNT > 0 OR WRITECOUNT > 0 \
GROUP BY FIELD, RECEIVER \
HAVING COUNT(*) > 1 AND SUM(READCOUNT) > 0 AND SUM(WRITECOUNT) > 0
LockSet.v2.insertSharedField=INSERT INTO FIELDINSTANCESHARED(FIELD,RECEIVER) VALUES (?,?)

LockSet.v2.fieldAccesses=SELECT A.TS,A.InThread, \
   CASE WHEN RW.Id IS NULL THEN D.Lock \
        ELSE RW.Id \
   END \
 FROM ACCESS A \
      INNER JOIN LOCKDURATION D ON D.InThread = A.InThread AND (A.TS BETWEEN D.Start AND D.Stop) AND State = 'HOLDING' \
      LEFT OUTER JOIN RWLOCK RW ON (RW.ReadLock = D.LOCK) OR (RW.WriteLock = D.LOCK) \
 WHERE A.Field = ? AND \
       A.Receiver = ?
#Walk over all of the held locks for a run
LockSet.v2.lockDurations=SELECT L.InThread, \
   L.Lock, \
   L.Type, \
   L.Start, \
   L.Stop, \
   L.StartEvent \
 FROM LOCKDURATION L \
 WHERE L.State = 'HOLDING' \
 ORDER BY Start
#Walk over all of the field accesses for a run
LockSet.v2.accesses=SELECT ID,TS, InThread, Field, Receiver, RW, UnderConstruction FROM ACCESS ORDER BY TS
LockSet.v2.indirectAccesses=SELECT ID,TS,INTHREAD,RECEIVER FROM INDIRECTACCESS ORDER BY TS
LockSet.v2.insertFieldLockSets=INSERT INTO FIELDLOCKSET (Field,Lock,Type) VALUES (?,?,?)
LockSet.v2.insertInstanceLockSets=INSERT INTO FIELDINSTANCELOCKSET (Field,Receiver,Lock,Type) VALUES (?,?,?,?)
LockSet.v2.insertStaticCounts=INSERT INTO FIELDSTATICTHREAD (Thread,Field,ReadCount,WriteCount) VALUES (?,?,?,?)
LockSet.v2.insertFieldCounts=INSERT INTO FIELDINSTANCETHREAD (Thread,Field,Receiver,ReadCount,WriteCount,ReadUCCount, WriteUCCount) VALUES (?,?,?,?,?,?,?)
LockSet.v2.updateAccessLocksHeld=INSERT INTO ACCESSLOCKSHELD (ACCESS,LOCKSHELD,LASTACQUISITION) VALUES (?,?,?)
LockSet.v2.updateIndirectAccessLocksHeld=INSERT INTO INDIRECTACCESSLOCKSHELD (ACCESS,LOCKSHELD,LASTACQUISITION) VALUES (?,?,?)
LockSet.v2.accessLocksHeldConstraint=ALTER TABLE ACCESSLOCKSHELD ADD CONSTRAINT ACCESSLOCKSHELDFK FOREIGN KEY (ACCESS) REFERENCES ACCESS (ID) ON DELETE NO ACTION ON UPDATE NO ACTION
LockSet.v2.accessLockAcquisitionConstraint=ALTER TABLE ACCESSLOCKSHELD ADD CONSTRAINT ACCESSLOCKACQUIREDFK FOREIGN KEY (LASTACQUISITION) REFERENCES LOCK (ID) ON DELETE NO ACTION ON UPDATE NO ACTION
LockSet.v2.indirectAccessLocksHeldConstraint=ALTER TABLE INDIRECTACCESSLOCKSHELD ADD CONSTRAINT INDIRECTACCESSLOCKSHELDFK FOREIGN KEY (ACCESS) REFERENCES INDIRECTACCESS (ID) ON DELETE NO ACTION ON UPDATE NO ACTION
LockSet.v2.indirectAccessLockAcquisitionConstraint=ALTER TABLE INDIRECTACCESSLOCKSHELD ADD CONSTRAINT INDIRECTACCESSLOCKACQUIREDFK FOREIGN KEY (LASTACQUISITION) REFERENCES LOCK (ID) ON DELETE NO ACTION ON UPDATE NO ACTION
# Calculate and write out the set of bad publishes
LockSet.badPublishes=INSERT INTO BADPUBLISH (RUN,FIELD,RECEIVER) SELECT F.RUN,F.ID,A.RECEIVER FROM FIELD F, ACCESS A \
 WHERE F.RUN = ? AND \
       A.RUN = F.RUN AND \
       A.FIELD = F.ID AND \
       A.UNDERCONSTRUCTION = 'Y' \
 GROUP BY F.RUN,F.ID,A.RECEIVER \
 HAVING COUNT(DISTINCT A.INTHREAD) > 1
# The set of fields that have writes outside of construction and are accessed by more than one thread
LockSet.interestingFields=INSERT INTO INTERESTINGFIELD (RUN,FIELD,RECEIVER) SELECT F0.RUN,F0.ID,A.RECEIVER FROM \
(SELECT DISTINCT F.RUN "RUN", F.ID "ID",A.RECEIVER "RECEIVER" FROM FIELD F, ACCESS A \
 WHERE F.RUN = ? AND \
       A.RUN = F.RUN AND \
       A.FIELD = F.ID AND \
       F.VOLATILE = 'N' AND \
       F.FINAL = 'N' AND \
       A.UNDERCONSTRUCTION = 'N' AND \
       A.RW = 'W') AS F0, ACCESS A \
WHERE A.RUN = F0.RUN AND A.FIELD = F0.ID AND A.RECEIVER = F0.RECEIVER OR (A.RECEIVER IS NULL AND F0.RECEIVER IS NULL) \
GROUP BY F0.RUN,F0.ID, A.RECEIVER \
HAVING COUNT(DISTINCT INTHREAD) > 1
# All field accesses, and the locks that are held.  If it is a RW lock, the parent lock is provided instead
LockSet.fieldAccesses=SELECT A.TS,A.InThread, \
   CASE WHEN RW.Id IS NULL THEN D.Lock \
        ELSE RW.Id \
   END \
 FROM ACCESS A \
      INNER JOIN LOCKDURATION D ON D.InThread = A.InThread AND (A.TS BETWEEN D.Start AND D.Stop) AND State = 'HOLDING' \
      LEFT OUTER JOIN RWLOCK RW ON (RW.ReadLock = D.LOCK) OR (RW.WriteLock = D.LOCK) \
 WHERE A.Run = ? AND \
       A.Field = ? AND \
       A.Receiver = ?
#Walk over all of the held locks for a run
LockSet.lockDurations=SELECT L.InThread, \
   CASE WHEN RW.Id IS NULL THEN L.Lock \
        ELSE RW.Id \
   END, \
   L.Start, \
   L.Stop \
 FROM LOCKDURATION L LEFT OUTER JOIN RWLOCK RW ON RW.Run = L.Run AND (RW.ReadLock = L.Lock OR RW.WriteLock = L.Lock) \
 WHERE L.State = 'HOLDING' AND L.Run = ? \
 ORDER BY Start
#Walk over all of the field accesses for a run
LockSet.accesses=SELECT TS, InThread, Field, Receiver, RW, UnderConstruction FROM ACCESS WHERE Run = ? ORDER BY TS
LockSet.insertFieldLockSets=INSERT INTO FIELDLOCKSET (Run,Field,Lock) VALUES (?,?,?)
LockSet.insertInstanceLockSets=INSERT INTO FIELDINSTANCELOCKSET (Run,Field,Receiver,Lock) VALUES (?,?,?,?)
LockSet.insertStaticCounts=INSERT INTO FIELDSTATICTHREAD (Run,Thread,Field,ReadCount,WriteCount) VALUES (?,?,?,?,?)
LockSet.insertFieldCounts=INSERT INTO FIELDINSTANCETHREAD (Run,Thread,Field,Receiver,ReadCount,WriteCount,ReadUCCount, WriteUCCount) VALUES (?,?,?,?,?,?,?,?)

SummaryInfo.emptyLockSets=SELECT \
  O.PackageName "Package", \
  O.ClassName "Class", \
  FI.FieldName "Field", \
  I.Field "FieldId", \
  FI.Static, \
  MIN(I.RECEIVER) \
 FROM OBJECT O \
 INNER JOIN FIELD FI ON FI.DeclaringType = O.Id \
 INNER JOIN INTERESTINGFIELD I ON FI.STATIC = 'N' AND I.FIELD=FI.ID \
 LEFT OUTER JOIN FIELDINSTANCELOCKSET F ON F.FIELD = I.FIELD AND F.RECEIVER = I.RECEIVER \
 WHERE F.LOCK IS NULL \
 GROUP BY O.PackageName, O.ClassName, FI.FieldName, I.Field, FI.Static \
 ORDER BY O.PackageName, O.ClassName, FI.FieldName

SummaryInfo.likelyLocks=SELECT LOCKS.*, \
       CAST (((CAST (LOCKS."Times Acquired__(r)" AS FLOAT)) / (CAST (ACCESSES.ACCESSCOUNT AS FLOAT))) * 100 AS DECIMAL) "Percentage Held__(r)" \
FROM \
(SELECT OBJID(LOCK) "Lock__(r)", LOCK "Lock__(hide)", COUNT(LOCK) "Times Acquired__(r)" \
 FROM \
  (SELECT L.LOCK FROM ACCESS A, ACCESSLOCKSHELD ALH, LOCK L \
   WHERE ALH.ACCESS = A.ID AND L.ID = ALH.LASTACQUISITION AND A.FIELD = ? AND A.RECEIVER = ? AND A.UNDERCONSTRUCTION = 'N' \
  UNION ALL \
  SELECT LH.LOCKHELD "LOCK" FROM ACCESS A, ACCESSLOCKSHELD ALH, LOCKSHELD LH \
   WHERE ALH.ACCESS = A.ID AND LH.LOCKEVENT = ALH.LASTACQUISITION AND A.FIELD = ? AND A.RECEIVER = ? AND A.UNDERCONSTRUCTION = 'N') AS FOO \
 GROUP BY LOCK) AS LOCKS, \
(SELECT COUNT(*) "ACCESSCOUNT" \
 FROM ACCESS A \
 WHERE A.FIELD = ? AND A.RECEIVER = ? AND A.UNDERCONSTRUCTION = 'N') AS ACCESSES \
 ORDER BY 3 DESC
SummaryInfo.likelyStaticLocks=SELECT LOCKS.*,  \
       CAST (((CAST (LOCKS."Times Acquired" AS FLOAT)) / (CAST (ACCESSES.ACCESSCOUNT AS FLOAT))) * 100 AS DECIMAL) "Percentage Held" \
FROM \
(SELECT OBJID(LOCK) "Lock", LOCK "LockId", COUNT(LOCK) "Times Acquired" \
 FROM  \
  (SELECT L.LOCK FROM ACCESS A, ACCESSLOCKSHELD ALH, LOCK L \
   WHERE ALH.ACCESS = A.ID AND L.ID = ALH.LASTACQUISITION AND A.FIELD = ? AND A.UNDERCONSTRUCTION = 'N' \
  UNION ALL  \
  SELECT LH.LOCKHELD "LOCK" FROM ACCESS A, ACCESSLOCKSHELD ALH, LOCKSHELD LH  \
   WHERE ALH.ACCESS = A.ID AND LH.LOCKEVENT = ALH.LASTACQUISITION AND A.FIELD = ?  AND A.UNDERCONSTRUCTION = 'N') AS FOO \
 GROUP BY LOCK) AS LOCKS, \
(SELECT COUNT(*) "ACCESSCOUNT"  \
 FROM ACCESS A  \
 WHERE A.FIELD = ? AND A.UNDERCONSTRUCTION = 'N') AS ACCESSES \
 ORDER BY 3 DESC

SummaryInfo.lockContentionSites=SELECT \
	SUM(D.DURATION) "Duration", \
	CO.PACKAGENAME "Package", \
    CO.CLASSNAME   "Class", \
    S.LOCATION     "Location", \
    S.ATLINE       "Line", \
    S.INFILE       "File", \
    S.METHODCLASS  "MethodCallClass", \
    S.METHODCALL   "MethodCallName", \
    D.INTHREAD "Thread" \
FROM LOCKDURATION D, LOCK L , TRACE TR, SITE S, OBJECT CO \
WHERE D.LOCK = ? AND \
	D.STATE = 'BLOCKING' AND \
	L.ID = D.STARTEVENT AND \
	TR.ID = L.TRACE AND \
	S.ID = TR.SITE AND \
	CO.ID = S.INCLASS \
GROUP BY D.INTHREAD, CO.PACKAGENAME, CO.CLASSNAME, S.LOCATION, S.ATLINE, S.INFILE, S.METHODCLASS, S.METHODCALL \
ORDER BY 2,3,4,5,6,7 

SummaryInfo.lockAcquiredAt=SELECT DISTINCT \
    CO.PACKAGENAME "Package", \
    CO.CLASSNAME   "Class", \
    S.LOCATION     "Location", \
    S.ATLINE       "Line", \
    S.INFILE       "File", \
    S.METHODCLASS  "MethodCallClass", \
    S.METHODCALL   "MethodCallName", \
FROM LOCK L  \
     INNER JOIN TRACE TR ON TR.ID = L.TRACE \
     INNER JOIN SITE S ON S.ID = TR.SITE \
     INNER JOIN OBJECT CO ON CO.ID = S.INCLASS \
WHERE L.LOCK = ? AND \
      L.STATE = 'AFTER ACQUISITION' \
ORDER BY 1,2,3,4,5
SummaryInfo.lockHeldAt=SELECT \
    CO.PACKAGENAME "Package", \
    CO.CLASSNAME   "Class", \
    S.LOCATION     "Location", \
    S.ATLINE       "Line", \
    S.INFILE       "File", \
    S.METHODCLASS  "MethodCallClass", \
    S.METHODCALL   "MethodCallName", \
    LCO.PACKAGENAME "LPackage", \
    LCO.CLASSNAME   "LClass", \
    LS.LOCATION     "LLocation", \
    LS.ATLINE       "LLine", \
    LS.INFILE       "LFile", \
    LS.METHODCLASS  "MethodCallClass", \
    LS.METHODCALL   "MethodCallName" \
FROM ACCESS A, TRACE TR, SITE S, OBJECT CO, ACCESSLOCKSHELD ALH, LOCK L, \
     TRACE LTR, SITE LS, OBJECT LCO \
WHERE A.FIELD = ? AND \
	      TR.ID = A.TRACE AND  \
      S.ID = TR.SITE AND \
      CO.ID = S.INCLASS AND \
      ALH.ACCESS = A.ID AND \
      L.ID = ALH.LASTACQUISITION AND \
      L.LOCK = ? AND \
      LTR.ID = L.TRACE AND \
      LS.ID = LTR.SITE AND \
      LCO.ID = LS.INCLASS \
UNION DISTINCT \
SELECT  \
    CO.PACKAGENAME "Package", \
    CO.CLASSNAME   "Class", \
    S.LOCATION     "Location", \
    S.ATLINE       "Line", \
    S.INFILE       "File", \
    S.METHODCLASS  "MethodCallClass", \
    S.METHODCALL   "MethodCallName", \
    LCO.PACKAGENAME "LPackage", \
    LCO.CLASSNAME   "LClass", \
    LS.LOCATION     "LLocation", \
    LS.ATLINE       "LLine", \
    LS.INFILE       "LFile", \
    LS.METHODCLASS  "MethodCallClass", \
    LS.METHODCALL   "MethodCallName" \
FROM ACCESS A, TRACE TR, SITE S, OBJECT CO, ACCESSLOCKSHELD ALH, LOCKSHELD LH, \
     LOCK L, TRACE LTR, SITE LS, OBJECT LCO \
WHERE A.FIELD = ? AND \
      TR.ID = A.TRACE AND \
      S.ID = TR.SITE AND \
      CO.ID = S.INCLASS AND \
      ALH.ACCESS = A.ID AND \
      LH.LOCKEVENT = ALH.LASTACQUISITION AND \
      LH.LOCKHELD = ? AND \
      L.ID = LH.LOCKHELDEVENT AND \
      LTR.ID = L.TRACE AND \
      LS.ID = LTR.SITE AND \
      LCO.ID = LS.INCLASS
SummaryInfo.lockNotHeldAt=SELECT DISTINCT  \
    CO.PACKAGENAME "Package", \
    CO.CLASSNAME   "Class", \
    S.LOCATION     "Location", \
    S.ATLINE       "Line", \
    S.INFILE       "File", \
    S.METHODCLASS  "MethodCallClass", \
    S.METHODCALL   "MethodCallName" \
FROM ACCESS A \
     INNER JOIN TRACE TR ON TR.ID = A.TRACE \
     INNER JOIN SITE S ON S.ID = TR.SITE \
     INNER JOIN OBJECT CO ON CO.ID = S.INCLASS \
     LEFT OUTER JOIN ACCESSLOCKSHELD ALH ON ALH.ACCESS = A.ID \
     LEFT OUTER JOIN LOCK L ON L.ID = ALH.LASTACQUISITION \
WHERE A.FIELD = ? AND \
        (L.LOCK IS NULL OR \
        (L.LOCK != ? AND \
         (NOT EXISTS (SELECT LOCKHELD FROM LOCKSHELD WHERE LOCKEVENT = ALH.LASTACQUISITION) OR \
          (NOT ? IN (SELECT LOCKHELD FROM LOCKSHELD WHERE LOCKEVENT = ALH.LASTACQUISITION)))))
SummaryInfo.lockInstanceHeldAt=SELECT \
    CO.PACKAGENAME "Package", \
    CO.CLASSNAME   "Class", \
    S.LOCATION     "Location", \
    S.ATLINE       "Line", \
    S.INFILE       "File", \
    S.METHODCLASS  "MethodCallClass", \
    S.METHODCALL   "MethodCallName", \
    LCO.PACKAGENAME "LPackage", \
    LCO.CLASSNAME   "LClass", \
    LS.LOCATION     "LLocation", \
    LS.ATLINE       "LLine", \
    LS.INFILE       "LFile", \
    LS.METHODCLASS  "MethodCallClass", \
    LS.METHODCALL   "MethodCallName" \
FROM ACCESS A, TRACE TR, SITE S, OBJECT CO, ACCESSLOCKSHELD ALH, LOCK L, \
     TRACE LTR, SITE LS, OBJECT LCO \
WHERE A.FIELD = ? AND \
      A.RECEIVER = ? AND \
      TR.ID = A.TRACE AND  \
      S.ID = TR.SITE AND \
      CO.ID = S.INCLASS AND \
      ALH.ACCESS = A.ID AND \
      L.ID = ALH.LASTACQUISITION AND \
      L.LOCK = ? AND \
      LTR.ID = L.TRACE AND \
      LS.ID = LTR.SITE AND \
      LCO.ID = LS.INCLASS \
UNION DISTINCT \
SELECT  \
    CO.PACKAGENAME "Package", \
    CO.CLASSNAME   "Class", \
    S.LOCATION     "Location", \
    S.ATLINE       "Line", \
    S.INFILE       "File", \
    S.METHODCLASS  "MethodCallClass", \
    S.METHODCALL   "MethodCallName", \
    LCO.PACKAGENAME "LPackage", \
    LCO.CLASSNAME   "LClass", \
    LS.LOCATION     "LLocation", \
    LS.ATLINE       "LLine", \
    LS.INFILE       "LFile", \
    LS.METHODCLASS  "MethodCallClass", \
    LS.METHODCALL   "MethodCallName" \
FROM ACCESS A, TRACE TR, SITE S, OBJECT CO, ACCESSLOCKSHELD ALH, LOCKSHELD LH, \
     LOCK L, TRACE LTR, SITE LS, OBJECT LCO \
WHERE A.FIELD = ? AND \
      A.RECEIVER = ? AND \
      TR.ID = A.TRACE AND \
      S.ID = TR.SITE AND \
      CO.ID = S.INCLASS AND \
      ALH.ACCESS = A.ID AND \
      LH.LOCKEVENT = ALH.LASTACQUISITION AND \
      LH.LOCKHELD = ? AND \
      L.ID = LH.LOCKHELDEVENT AND \
      LTR.ID = L.TRACE AND \
      LS.ID = LTR.SITE AND \
      LCO.ID = LS.INCLASS
SummaryInfo.lockInstanceNotHeldAt=SELECT DISTINCT \
    CO.PACKAGENAME "Package", \
    CO.CLASSNAME   "Class", \
    S.LOCATION     "Location", \
    S.ATLINE       "Line", \
    S.INFILE       "File", \
    S.METHODCLASS  "MethodCallClass", \
    S.METHODCALL   "MethodCallName" \
FROM ACCESS A \
     INNER JOIN TRACE TR ON TR.ID = A.TRACE \
     INNER JOIN SITE S ON S.ID = TR.SITE \
     INNER JOIN OBJECT CO ON CO.ID = S.INCLASS \
     LEFT OUTER JOIN ACCESSLOCKSHELD ALH ON ALH.ACCESS = A.ID \
     LEFT OUTER JOIN LOCK L ON L.ID = ALH.LASTACQUISITION \
WHERE A.FIELD = ? AND \
      A.RECEIVER = ? AND \
        (L.LOCK IS NULL OR \
		(L.LOCK != ? AND \
         (NOT EXISTS (SELECT LOCKHELD FROM LOCKSHELD WHERE LOCKEVENT = ALH.LASTACQUISITION) OR \
          (NOT ? IN (SELECT LOCKHELD FROM LOCKSHELD WHERE LOCKEVENT = ALH.LASTACQUISITION)))))
SummaryInfo.emptyStaticLockSets=SELECT \
  O.PackageName "Package", \
  O.ClassName "Class", \
  FI.FieldName "Field", \
  I.FIELD "FieldId", \
  FI.Static \
 FROM OBJECT O \
 INNER JOIN FIELD FI ON FI.DeclaringType = O.Id \
 INNER JOIN INTERESTINGFIELD I ON I.RECEIVER IS NULL AND I.FIELD=FI.ID \
 LEFT OUTER JOIN FIELDLOCKSET F ON F.FIELD = I.FIELD \
 WHERE F.LOCK IS NULL \
 ORDER BY O.PackageName,O.ClassName,FI.FieldName 
SummaryInfo.badPublishes=select \
  O.PackageName "Package", \
  O.ClassName "Class", \
  F.FieldName "Field", \
  F.Id "FieldId", \
  F.Static "Static", \
  MIN(B.RECEIVER) \
from BADPUBLISH B, \
     OBJECT O, \
     FIELD F \
where \
  F.ID = B.FIELD \
  and F.DeclaringType = O.Id \
group by O.PackageName,O.ClassName,F.FieldName,F.Id,F.Static \
order by O.PackageName,O.ClassName,F.FieldName
SummaryInfo.underConstructionAccesses=SELECT \
       THO.THREADNAME "Thread", \
       CASE WHEN A.RW = 'R' THEN 'Y' ELSE 'N' END "IsRead", \
       A.TS "Time", \
       A.TRACE "ATRACE" \
 FROM ACCESS A, OBJECT THO, TRACE T, SITE S, OBJECT CO \
WHERE  \
   T.ID = A.TRACE AND \
   S.ID = T.SITE AND  \
   CO.ID = S.INCLASS AND \
   THO.Id = A.InThread AND \
   A.FIELD = ? AND \
   A.RECEIVER = ? AND \
   A.UNDERCONSTRUCTION = 'Y' \
ORDER BY 1,2 ASC
SummaryInfo.instanceFields=select \
  O.PackageName "Package", \
  O.ClassName "Class", \
  F.FieldName "Field", \
  SUM(FI.ReadUCCount) + SUM(FI.ReadCount) "Reads", \
  SUM(FI.WriteUCCount) + SUM(FI.WriteCount) "Writes", \
  SUM(FI.ReadUCCount) "Reads During Construction", \
  SUM(FI.WriteUCCount) "Writes During Construction", \
  MAX(FIRC.RC) "Instances", \
  COUNT(DISTINCT THO.ThreadName) "Threads Involved", \
  F.Id "FieldId" \
from OBJECT O, \
     FIELD F, \
     FIELDINSTANCETHREAD FI, \
     OBJECT THO, \
     (SELECT FIELD, COUNT(DISTINCT RECEIVER) "RC" FROM FIELDINSTANCETHREAD GROUP BY FIELD) AS FIRC \
where \
  F.DeclaringType = O.Id \
  and FI.FIELD = F.ID \
  and THO.ID = FI.Thread \
  and FIRC.FIELD = F.ID \
group by O.PackageName,O.ClassName,F.FieldName,F.Id \
order by O.PackageName,O.ClassName,F.FieldName
SummaryInfo.staticFields=select \
  O.PackageName "Package", \
  O.ClassName "Class", \
  F.FieldName "Field", \
  THO.ThreadName "Thread", \
  FS.ReadCount "Read Count", \
  FS.WriteCount "Write Count", \
  THO.ThreadName "Threads Involved", \
  F.ID "FieldId" \
from OBJECT O, \
     FIELD F, \
     FIELDSTATICTHREAD FS, \
     OBJECT THO \
where \
  F.DeclaringType = O.Id \
  and FS.FIELD = F.ID  \
  and THO.ID = FS.Thread \
order by O.PackageName,O.ClassName,F.FieldName,THO.ThreadName

SummaryInfo.threads = SELECT A.INTHREAD "ThreadId", \
 OBJID(A.INTHREAD) "Thread__(c)", \
 CASE WHEN L.LFIRST IS NULL OR A.AFIRST < L.LFIRST THEN A.AFIRST ELSE L.LFIRST END "Thread Start", \
 CASE WHEN L.LLAST IS NOT NULL AND A.ALAST < L.LLAST THEN L.LLAST ELSE A.ALAST END "Thread Stop", \
 CASE WHEN L.BLOCK IS NULL THEN 0 ELSE L.BLOCK END "Total Block Time__(r)", \
 CASE WHEN L.BLOCK_AVE IS NULL THEN 0 ELSE L.BLOCK_AVE END "Average Block Time__(r)" \
FROM \
  (SELECT INTHREAD, MIN(TS) "AFIRST", MAX(TS) "ALAST" \
   FROM ACCESS \
   GROUP BY INTHREAD) AS A LEFT OUTER JOIN \
  (SELECT INTHREAD, MIN(START) "LFIRST", MAX(STOP) "LLAST", \
          sum(Duration) "BLOCK", \
          sum(duration) / count (startevent) "BLOCK_AVE" \
   FROM LOCKDURATION \
   GROUP BY INTHREAD) AS L \
ON A.INTHREAD = L.INTHREAD

SummaryInfo.threadCount=SELECT COUNT(*) FROM OBJECT WHERE FLAG = 'T'
SummaryInfo.classCount=SELECT COUNT(*) FROM OBJECT WHERE FLAG = 'C'
SummaryInfo.objectCount=SELECT COUNT(*) FROM OBJECT

SummaryInfo.staticFieldCoverage=SELECT DISTINCT \
  F.ID, \
  O.PACKAGENAME, \
  O.CLASSNAME, \
  F.FIELDNAME, \
  F.STATIC, \
  FS.THREAD \
FROM FIELD F, \
     OBJECT O, \
     FIELDINSTANCETHREAD FS \
WHERE FS.FIELD = F.ID AND \
      O.ID = F.DECLARINGTYPE
SummaryInfo.instanceFieldCoverage=SELECT DISTINCT \
  F.ID, \
  O.PACKAGENAME, \
  O.CLASSNAME, \
  F.FIELDNAME, \
  F.STATIC, \
  FI.THREAD \
FROM FIELD F, \
     OBJECT O, \
     FIELDINSTANCETHREAD FI \
WHERE FI.FIELD = F.ID AND \
      O.ID = F.DECLARINGTYPE

LockInfo.insertDoubleLockedMethod=INSERT INTO DOUBLELOCKEDMETHODS(LOCK,TYPE,INCLASS,LOCATION,LOCATIONSPEC,LOCATIONCODE) VALUES (?,?,?,?,?,?)
LockInfo.potentialDoubleLockedMethods=SELECT L.LOCK, L.TYPE, S.LOCATION, S.LOCATIONSPEC, S.LOCATIONCODE, S.INCLASS  \
   FROM  \
      LOCK L,  \
      TRACE T,  \
      SITE S  \
   WHERE  \
      T.ID = L.TRACE AND  \
      S.ID = T.SITE AND  \
      L.STATE = 'AFTER ACQUISITION'  \
   GROUP BY  \
      L.LOCK, L.TYPE, S.LOCATION,S.LOCATIONCODE,S.LOCATIONSPEC,S.INCLASS  \
   HAVING COUNT(DISTINCT S.ID) > 1 
LockInfo.testDoubleLockedMethod=SELECT \
    RL.LOCK \
FROM \
   LOCK RL INNER JOIN   \
   TRACE RT ON RT.ID = RL.TRACE INNER JOIN  \
   SITE RS ON RS.ID = RT.SITE AND RS.LOCATION = ? AND RS.LOCATIONSPEC = ? AND RS.INCLASS = ? INNER JOIN  \
   LOCK AL ON AL.LOCK = ? AND AL.TYPE = ? AND AL.STATE = 'AFTER ACQUISITION' INNER JOIN  \
   TRACE ALT ON ALT.ID = AL.TRACE INNER JOIN  \
   SITE ALS ON ALS.ID = ALT.SITE AND ALS.LOCATION = ? AND ALS.LOCATIONSPEC = ? AND ALS.INCLASS = ? AND ALS.ATLINE > RS.ATLINE \
WHERE \
    RL.LOCK = ? AND RL.TYPE = ? AND RL.STATE = 'AFTER RELEASE'      

CoverageInfo.fieldCoverage=SELECT DISTINCT A.TRACE, A.INTHREAD \
FROM ACCESS A \
ORDER BY 1

CoverageInfo.lockCoverage=SELECT DISTINCT L.TRACE, L.INTHREAD \
FROM LOCK L \
ORDER BY 1

CoverageInfo.contentionHotSpots=SELECT SUM(LD.DURATION), LD.INTHREAD, O.PACKAGENAME, O.CLASSNAME, S.LOCATION, S.ATLINE, S.INFILE \
FROM LOCKDURATION LD, \
     LOCK LE, \
     TRACE TR, \
     SITE S, \
     OBJECT O \
WHERE LD.STATE = 'BLOCKING' AND \
      LE.ID = LD.STARTEVENT AND \
      TR.ID = LE.TRACE AND \
      S.ID = TR.SITE AND \
      O.ID = S.INCLASS \
GROUP BY LD.INTHREAD, O.PACKAGENAME, O.CLASSNAME, S.LOCATION, S.ATLINE, S.INFILE \
ORDER BY 2,3,4,5,6,7,1 DESC

Deadlock.lockContention=select OBJID(Lock) "Lock", \
  count(lock)   				 as "Times Acquired", \
  sum(Duration) 				 as "Total Block Time",  \
  (sum(duration) / count (lock)) as "Average Block Time", \
  Lock "Lock" \
from LOCKDURATION    \
where State = 'BLOCKING' \
group by Lock \
order by sum(duration) / count (lock) desc

Deadlock.lockCycles=select Component "Cycle", OBJID(LockHeld) "LockHeld__(r)|", LockHeld "LockHeldId", \
  OBJID(LockAcquired) "LockAcquired__(r)", LockAcquired "LockAcquiredId", \
  Count "Count__(r)", FirstTime "FirstTime", LastTime "LastTime", LockHeld "LockHeld__(hide)", LockAcquired "LockAcquired__(hide)" \
from lockcycle \
where count > 0 \
order by component, count desc

Deadlock.lockCycleThreads=INSERT INTO LOCKCYCLETHREAD SELECT \
  C.COMPONENT, \
  C.LOCKHELD, \
  C.LOCKHELDTYPE, \
  C.LOCKACQUIRED, \
  C.LOCKACQUIREDTYPE, \
  H.INTHREAD, \
  COUNT(H.INTHREAD), \
  MIN(L.TS), \
  MAX(L.TS) \
FROM \
  LOCKCYCLE C, \
  LOCKSHELD H, \
  LOCK L \
WHERE \
  H.LOCKACQUIRED = C.LOCKACQUIRED AND \
  H.LOCKACQUIREDTYPE = C.LOCKACQUIREDTYPE AND \
  H.LOCKHELD = C.LOCKHELD AND \
  H.LOCKHELDTYPE = C.LOCKHELDTYPE AND \
  L.ID = H.LOCKEVENT \
GROUP BY C.COMPONENT,C.LOCKHELD,C.LOCKHELDTYPE,C.LOCKACQUIRED,C.LOCKACQUIREDTYPE,H.INTHREAD

Deadlock.lockEdgeThreads=select distinct tho.threadname \
from LOCKSHELD as lh, OBJECT tho \
where lh.LockHeld=? \
  and lh.LockAcquired=? \
  and tho.Id = lh.InThread \
order by tho.threadname 

Deadlock.lockEdgeTraces=SELECT tr.id "Acquired Stack Trace", lh.LockEvent "Lock Event", \
                               htr.id "Held Stack Trace", lh.LockHeldEvent "Lock Held Event" \
from LOCKSHELD as lh, \
     LOCK l, \
     TRACE tr, \
     LOCK hl, \
     TRACE htr \
where lh.LockHeld=? \
  and lh.LockAcquired=? \
  and lh.LockEvent=l.Id \
  and tr.Id = l.Trace \
  and lh.LockHeldEvent = hl.Id \
  and htr.Id = hl.Trace
Deadlock.lockEdgeLockTrace=SELECT D.Lock "LockId", \
      OBJID(D.Lock) "Lock", \
      LO.PackageName "Package", \
      LO.ClassName "Class", \
      S.AtLine "Line" \
FROM LOCK L, \
 LOCKDURATION D, \
 LOCK LL, \
 TRACE T, \
 SITE S, \
 OBJECT LO \
WHERE D.InThread = L.InThread AND (L.TS BETWEEN D.START AND D.STOP) AND D.STATE = 'HOLDING' AND \
      LL.Id = D.StartEvent AND \
      T.Id = LL.Trace AND \
      S.Id = T.Site AND \
      LO.Id = S.InClass AND \
      L.Id = ? \
ORDER BY D.START DESC


#------------------------------------------------------------------------
# Flashlight-JSure Region Queries
#------------------------------------------------------------------------
Flashlight.Region.lockIsThis=SELECT DISTINCT \
  LCO.PACKAGENAME, \
  LCO.CLASSNAME, \
  'this', \
  FIL.RECEIVER, \
  'N', \
  F.FIELDNAME, \
  F.ID, \
  F.VISIBILITY, \
  F.STATIC, \
  F.FINAL, \
  F.VOLATILE, \
  CASE WHEN FFIL.FIELD IS NULL THEN 'N' ELSE 'Y' END \
FROM FIELDINSTANCELOCKSET FIL \
INNER JOIN OBJECT LO ON \
  LO.ID = FIL.LOCK AND \
  LO.ID = FIL.RECEIVER \
INNER JOIN FIELD F ON \
  F.ID = FIL.FIELD \
INNER JOIN OBJECT LCO ON \
  LCO.ID = F.DECLARINGTYPE \
LEFT OUTER JOIN FIELDASSIGNMENT FFA ON \
  FFA.FIELD = FIL.FIELD AND \
  FFA.RECEIVER = FIL.RECEIVER \
LEFT OUTER JOIN FIELDINSTANCELOCKSET FFIL ON \
  FFIL.RECEIVER = FFA.VALUE AND \
  FFIL.LOCK = FIL.LOCK \
ORDER BY 1,2,3,4,5,6,7
Flashlight.Region.lockIsClass=SELECT DISTINCT \
  LCO.PACKAGENAME, \
  LCO.CLASSNAME, \
  'class', \
  FL.LOCK, \
  'Y', \
  F.FIELDNAME, \
  F.ID, \
  F.VISIBILITY, \
  F.STATIC, \
  F.FINAL, \
  F.VOLATILE, \
  CASE WHEN FFIL.FIELD IS NULL THEN 'N' ELSE 'Y' END \
FROM FIELDLOCKSET FL \
INNER JOIN FIELD F ON \
  F.ID = FL.FIELD AND \
  F.DECLARINGTYPE = FL.LOCK \
INNER JOIN OBJECT LCO ON \
  LCO.ID = F.DECLARINGTYPE \
LEFT OUTER JOIN FIELDASSIGNMENT FFA ON \
  FFA.FIELD = FL.FIELD AND \
  FFA.RECEIVER IS NULL \
LEFT OUTER JOIN FIELDINSTANCELOCKSET FFIL ON \
  FFIL.RECEIVER = FFA.VALUE AND \
  FFIL.LOCK = FL.LOCK \
ORDER BY 1,2,3,4,5,6,7
Flashlight.Region.lockIsField=SELECT DISTINCT \
  LFC.PACKAGENAME, \
  LFC.CLASSNAME, \
  LF.FIELDNAME,  \
  FIL.LOCK, \
  LF.STATIC, \
  F.FIELDNAME, \
  F.ID, \
  F.VISIBILITY, \
  F.STATIC, \
  F.FINAL, \
  F.VOLATILE, \
  CASE WHEN FFIL.FIELD IS NULL THEN 'N' ELSE 'Y' END \
FROM FIELDINSTANCELOCKSET FIL \
INNER JOIN OBJECT O ON \
  O.ID = FIL.RECEIVER \
INNER JOIN OBJECT CO ON \
  CO.ID = O.TYPE \
INNER JOIN FIELD F ON \
  F.ID = FIL.FIELD \
INNER JOIN FIELDASSIGNMENT FA ON \
  FA.VALUE = FIL.LOCK \
INNER JOIN FIELD LF ON \
  LF.ID = FA.FIELD \
INNER JOIN OBJECT LFC ON \
  LFC.ID = LF.DECLARINGTYPE \
LEFT OUTER JOIN FIELDASSIGNMENT FFA ON \
  FFA.FIELD = FIL.FIELD AND \
  FFA.RECEIVER = FIL.RECEIVER \
LEFT OUTER JOIN FIELDINSTANCELOCKSET FFIL ON \
  FFIL.RECEIVER = FFA.VALUE AND \
  FFIL.LOCK = FIL.LOCK \
WHERE CO.PACKAGENAME = LFC.PACKAGENAME AND CO.CLASSNAME = LFC.CLASSNAME \
ORDER BY 1,2,3,4,5,6,7
Flashlight.Region.observed=SELECT DISTINCT \
  CO.PACKAGENAME "Package__|('package.gif')", \
  CO.CLASSNAME "Class__('class.gif')", \
  F.FIELDNAME "Field", \
  F.VISIBILITY, \
  F.STATIC, \
  F.FINAL, \
  F.VOLATILE \
FROM FIELDINSTANCELOCKSET FIL \
INNER JOIN OBJECT O ON \
  O.ID = FIL.RECEIVER \
INNER JOIN OBJECT CO ON \
  CO.ID = O.TYPE \
INNER JOIN FIELD F ON \
  F.ID = FIL.FIELD \
INNER JOIN OBJECT FLO ON \
  FLO.ID = FIL.LOCK \
INNER JOIN OBJECT FLCO ON \
  FLCO.ID = FLO.TYPE \
ORDER BY 1,2,3,4
Flashlight.Region.lockTraces=SELECT DISTINCT \
  L.TRACE \
FROM LOCK L \
WHERE L.LOCK = ? AND \
L.STATE = 'AFTER ACQUISITION' AND \
L.SUCCESS IS NULL OR L.SUCCESS = 'Y'
Flashlight.Region.fieldTraces=SELECT DISTINCT \
  A.TRACE \
FROM ACCESS A \
WHERE A.FIELD = ? AND \
A.UNDERCONSTRUCTION = 'N'

Flashlight.ThreadNamePostPrep.selectThreads=SELECT ID,THREADNAME FROM OBJECT WHERE THREADNAME IS NOT NULL ORDER BY THREADNAME
Flashlight.ThreadNamePostPrep.updateThreadNames=UPDATE OBJECT SET THREADNAME = ? WHERE ID = ?
Flashlight.LockIsClass=UPDATE LOCK SET LOCKISCLASS = 'Y' WHERE ID IN (SELECT L.ID FROM LOCK L, TRACE T, SITE S WHERE S.INCLASS = L.LOCK AND S.ID = T.SITE AND T.ID = L.TRACE) 
#------------------------------------------------------------------------
# surelogic.com Services Queries
#------------------------------------------------------------------------
WebServices.insertSupportRequest=INSERT INTO SUPPORT_REQUEST (REMOTE_IP, REMOTE_HOSTNAME, REQUEST_TYPE, HTTP_HEADERS, BODY, SENDER, CLIENT_OS, CLIENT_JAVA, CLIENT_IDE, LICENSE_ID, LICENSE_TOOL, LICENSE_HOLDER, LICENSE_EXPIRATION) values (?,?,?,?,?,?,?,?,?,?,?,?,?)
WebServices.insertEvaluationLicense=INSERT INTO FL_LICENSE_EVALUATION (DATE_TIME,EMAIL,FIRSTNAME,LASTNAME,COMPANY,LICENSE) VALUES (?,?,?,?,?,?)
WebServices.checkBlacklist=SELECT * FROM LICENSE_BLACKLIST WHERE LICENSE_ID = ?

WebServices.logNetCheck=INSERT INTO LICENSE_NETCHECK_LOG (DATE_TIME, REMOTE_IP, LICENSE_ID, EVENT_DESCRIPTION) VALUES (?,?,?,?)
WebServices.updateCheckCount=UPDATE LICENSE_NETCHECK_COUNTS SET %1$s = %1$s + 1 WHERE LICENSE_ID = '%2$s'   
WebServices.insertCheckCount=INSERT INTO LICENSE_NETCHECK_COUNTS (LICENSE_ID,INSTALL_COUNT,RENEWAL_COUNT,REMOVAL_COUNT,BLACKLIST_COUNT,TOO_MANY_COUNT) VALUES (?,0,0,0,0,0)
WebServices.selectCheckCount=SELECT INSTALL_COUNT,RENEWAL_COUNT,REMOVAL_COUNT,BLACKLIST_COUNT,TOO_MANY_COUNT FROM LICENSE_NETCHECK_COUNTS WHERE LICENSE_ID = ?

WebServices.insertLicenseInfo=INSERT INTO LICENSE_NETCHECK_DESCRIPTION (LICENSE_ID,LICENSE_PRODUCT,LICENSE_HOLDER,LICENSE_DURATION_IN_DAYS,LICENSE_INSTALL_BEFORE_DATE,LICENSE_TYPE,MAX_ACTIVE) VALUES (?,?,?,?,?,?,?)
WebServices.selectLicenseInfo=SELECT D.LICENSE_ID,D.LICENSE_PRODUCT,D.LICENSE_HOLDER,D.LICENSE_DURATION_IN_DAYS,D.LICENSE_INSTALL_BEFORE_DATE,D.LICENSE_TYPE,D.MAX_ACTIVE, CASE WHEN B.LICENSE_ID IS NULL THEN 'no' ELSE 'yes' END FROM LICENSE_NETCHECK_DESCRIPTION D LEFT OUTER JOIN LICENSE_BLACKLIST B ON B.LICENSE_ID = D.LICENSE_ID 
WebServices.selectLicenseInfoById=SELECT D.LICENSE_PRODUCT,D.LICENSE_HOLDER,D.LICENSE_DURATION_IN_DAYS,D.LICENSE_INSTALL_BEFORE_DATE,D.LICENSE_TYPE,D.MAX_ACTIVE, CASE WHEN B.LICENSE_ID IS NULL THEN 'no' ELSE 'yes' END FROM LICENSE_NETCHECK_DESCRIPTION D LEFT OUTER JOIN LICENSE_BLACKLIST B ON B.LICENSE_ID = D.LICENSE_ID WHERE D.LICENSE_ID = ?

WebServices.removeFromBlacklist=DELETE FROM LICENSE_BLACKLIST WHERE LICENSE_ID = ?
WebServices.addToBlacklist=INSERT INTO LICENSE_BLACKLIST (LICENSE_ID) VALUES (?)
WebServices.listBlacklistedUUIDs=SELECT \
   MAX(LNL.DATE_TIME), LND.LICENSE_ID, LND.LICENSE_PRODUCT, LND.LICENSE_HOLDER, \
   LNC.INSTALL_COUNT, LNC.RENEWAL_COUNT, LNC.REMOVAL_COUNT, LNC.BLACKLIST_COUNT, LNC.TOO_MANY_COUNT \
 FROM LICENSE_BLACKLIST B, LICENSE_NETCHECK_DESCRIPTION LND, LICENSE_NETCHECK_COUNTS LNC, LICENSE_NETCHECK_LOG LNL \
 WHERE LND.LICENSE_ID = B.LICENSE_ID AND LNC.LICENSE_ID = LND.LICENSE_ID AND LNL.LICENSE_ID = LND.LICENSE_ID \
 GROUP BY LND.LICENSE_ID, LND.LICENSE_PRODUCT, LND.LICENSE_HOLDER, LNC.INSTALL_COUNT, LNC.RENEWAL_COUNT, LNC.REMOVAL_COUNT, LNC.BLACKLIST_COUNT, LNC.TOO_MANY_COUNT \
 ORDER BY 1 DESC 

WebServices.licenseSummary=SELECT \
   MAX(LNL.DATE_TIME), LND.LICENSE_ID, LND.LICENSE_PRODUCT, LND.LICENSE_HOLDER, \
   LNC.INSTALL_COUNT, LNC.RENEWAL_COUNT, LNC.REMOVAL_COUNT, LNC.BLACKLIST_COUNT, LNC.TOO_MANY_COUNT \
 FROM LICENSE_NETCHECK_DESCRIPTION LND, LICENSE_NETCHECK_COUNTS LNC, LICENSE_NETCHECK_LOG LNL \
 WHERE LNC.LICENSE_ID = LND.LICENSE_ID AND LNL.LICENSE_ID = LND.LICENSE_ID \
 GROUP BY LND.LICENSE_ID, LND.LICENSE_PRODUCT, LND.LICENSE_HOLDER, LNC.INSTALL_COUNT, LNC.RENEWAL_COUNT, LNC.REMOVAL_COUNT, LNC.BLACKLIST_COUNT, LNC.TOO_MANY_COUNT \
 ORDER BY 1 DESC 
WebServices.selectNetChecks=SELECT DATE_TIME,REMOTE_IP,LICENSE_ID,EVENT_DESCRIPTION FROM LICENSE_NETCHECK_LOG ORDER BY DATE_TIME DESC
WebServices.selectNetChecksBefore=SELECT DATE_TIME,REMOTE_IP,LICENSE_ID,EVENT_DESCRIPTION FROM LICENSE_NETCHECK_LOG WHERE DATE_TIME < ? ORDER BY DATE_TIME DESC
WebServices.selectNetChecksByID=SELECT DATE_TIME,REMOTE_IP,EVENT_DESCRIPTION FROM LICENSE_NETCHECK_LOG  WHERE LICENSE_ID = ? ORDER BY DATE_TIME DESC

WebServices.selectNetCheckCounts=SELECT LICENSE_ID,INSTALL_COUNT,RENEWAL_COUNT,REMOVAL_COUNT,BLACKLIST_COUNT,TOO_MANY_COUNT FROM LICENSE_NETCHECK_COUNTS

WebServices.updateInstallCount=UPDATE LICENSE_NETCHECK_DESCRIPTION SET MAX_ACTIVE = ? WHERE LICENSE_ID = ?

WebServices.searchByID=SELECT \
   MAX(LNL.DATE_TIME), LND.LICENSE_ID, LND.LICENSE_PRODUCT, LND.LICENSE_HOLDER, \
   LNC.INSTALL_COUNT, LNC.RENEWAL_COUNT, LNC.REMOVAL_COUNT, LNC.BLACKLIST_COUNT, LNC.TOO_MANY_COUNT \
 FROM LICENSE_NETCHECK_DESCRIPTION LND, LICENSE_NETCHECK_COUNTS LNC, LICENSE_NETCHECK_LOG LNL \
 WHERE LNC.LICENSE_ID = LND.LICENSE_ID AND LNL.LICENSE_ID = LND.LICENSE_ID AND LND.LICENSE_ID LIKE ? \
 GROUP BY LND.LICENSE_ID, LND.LICENSE_PRODUCT, LND.LICENSE_HOLDER, LNC.INSTALL_COUNT, LNC.RENEWAL_COUNT, LNC.REMOVAL_COUNT, LNC.BLACKLIST_COUNT, LNC.TOO_MANY_COUNT

WebServices.searchByName=SELECT \
   MAX(LNL.DATE_TIME), LND.LICENSE_ID, LND.LICENSE_PRODUCT, LND.LICENSE_HOLDER, \
   LNC.INSTALL_COUNT, LNC.RENEWAL_COUNT, LNC.REMOVAL_COUNT, LNC.BLACKLIST_COUNT, LNC.TOO_MANY_COUNT \
 FROM LICENSE_NETCHECK_DESCRIPTION LND, LICENSE_NETCHECK_COUNTS LNC, LICENSE_NETCHECK_LOG LNL \
 WHERE LNC.LICENSE_ID = LND.LICENSE_ID AND LNL.LICENSE_ID = LND.LICENSE_ID AND LND.LICENSE_HOLDER LIKE ? \
 GROUP BY LND.LICENSE_ID, LND.LICENSE_PRODUCT, LND.LICENSE_HOLDER, LNC.INSTALL_COUNT, LNC.RENEWAL_COUNT, LNC.REMOVAL_COUNT, LNC.BLACKLIST_COUNT, LNC.TOO_MANY_COUNT

#------------------------------------------------------------------------
# surelogic.com PayPal Payment Queries
#------------------------------------------------------------------------
Payment.insertPayment=INSERT INTO PAYPAL_TXN (TXN_ID,DATE_TIME,ITEM_NAME,ITEM_NUMBER,ITEM_OPTION,PAYMENT_STATUS,PAYMENT_AMOUNT,PAYER_EMAIL,PAYER_ID,RECEIVER_EMAIL,SENDTO_EMAIL,ADDRESS_COUNTRY,ADDRESS_CITY,ADDRESS_CC,ADDRESS_NAME,ADDRESS_STATE,ADDRESS_STATUS,ADDRESS_STREET,ADDRESS_ZIP,CONTACT_PHONE,FIRST_NAME,LAST_NAME,PAYER_BUSINESS_NAME) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
Payment.checkTxn=SELECT * FROM PAYPAL_TXN WHERE TXN_ID = ?
Payment.insertLicense=INSERT INTO LICENSE (TXN_ID,SENT_TIME,EMAIL,LICENSE_TYPE,LICENSE) VALUES (?,?,?,?,?)